use strict;

# check for bad value support
use PDL::Config;
my $bvalflag = $PDL::Config{WITH_BADVAL} || 0;

pp_addhdr(<<'EOD');

#ifndef RAND_MAX
#error "You must have a working RAND_MAX! Something's wrong with your include files"
#endif

EOD

pp_addpm({At=>'Top'},<<'EOD');

use PDL::Slices;
use Carp;

=head1 NAME

PDL::Primitive - primitive operations for pdl

=head1 DESCRIPTION

This module provides some primitive and useful functions defined
using PDL::PP and able to use the new indexing tricks.

See L<PDL::Indexing|PDL::Indexing> for how to use indices creatively.
For explanation of the signature format, see L<PDL::PP|PDL::PP>.

=head1 SYNOPSIS

 use PDL::Primitive;

=cut

EOD

pp_addpm({At=>'Bot'},<<'EOD');

=head1 AUTHOR

Copyright (C) Tuomas J. Lukka 1997 (lukka@husc.harvard.edu). Contributions
by Christian Soeller (c.soeller@auckland.ac.nz), Karl Glazebrook
(kgb@aaoepp.aao.gov.au), and Craig DeForest (deforest@boulder.swri.edu).
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution,
the copyright notice should be included in the file.

=cut

EOD


################################################################
#  a whole bunch of quite basic functions for inner, outer
#  and matrix products (operations that are not normally
#  available via operator overloading)
################################################################

pp_def(
       'inner',
       HandleBad => 1,
       Pars => 'a(n); b(n); [o]c();', 
       Code => 
       'double tmp = 0;
        loop(n) %{ tmp += $a() * $b(); %}
        $c() = tmp;',
       BadCode => 
       'double tmp = 0;
        int flag = 0;
        loop(n) %{ 
           if ( $ISGOOD(a()) && $ISGOOD(b()) ) { tmp += $a() * $b(); flag = 1; }
        %}
        if ( flag ) { $c() = tmp; }
        else        { $SETBAD(c()); $PDLSTATESETBAD(c); }',
       CopyBadStatusCode => '',
       Doc => '
=for ref

Inner product over one dimension

 c = sum_i a_i * b_i

',
       BadDoc => 
'If C<a() * b()> contains only bad data,
C<c()> is set bad. Otherwise C<c()> will have its bad flag cleared,
as it will not contain any bad values.',
       ); # pp_def( inner )


pp_def(
       'outer',
       HandleBad => 1,
       Pars => 'a(n); b(m); [o]c(n,m);',
       Code => 
       'loop(n,m) %{ 
          $c() = $a() * $b(); 
        %}',
       BadCode => 
       'loop(n,m) %{ 
          if ( $ISBAD(a()) || $ISBAD(b()) ) {
             $SETBAD(c());
          } else {
             $c() = $a() * $b(); 
          }
        %}',
       Doc => '
=for ref

outer product over one dimension

Naturally, it is possible to achieve the effects of outer
product simply by threading over the "C<*>"
operator but this function is provided for convenience.

'); # pp_def( outer )


pp_addpm(<<'EOD');
=head2 matmult

=for sig

 Signature: (a(x,y),b(y,z),[o]c(x,z))

=for ref

Matrix multiplication

We peruse the inner product to define matrix multiplication
via a threaded inner product

=cut

  sub PDL::matmult {
    barf "Invalid number of arguments for matmult" if $#_ < 1;
    my ($a,$b,$c) = @_;
    while ($a->getndims < 2) {$a = $a->dummy(-1)} # promote if necessary
    while ($b->getndims < 2) {$b = $b->dummy(-1)}
    if(!defined $c) {$c = PDL->nullcreate($a)}
    $a->dummy(1)->inner($b->xchg(0,1)->dummy(2),$c);
    return $c;
  }

  *matmult = \&PDL::matmult;

EOD

pp_add_exported('', 'matmult');

pp_def(
       'innerwt',
       HandleBad => 1,
       Pars => 'a(n); b(n); c(n); [o]d();',
       Code => 
       'double tmp = 0;
	loop(n) %{ 
           tmp += $a() * $b() * $c(); 
        %}
	$d() = tmp;',
       BadCode => 
       'double tmp = 0;
        int flag = 0;

	loop(n) %{ 
           if ( $ISGOOD(a()) && $ISGOOD(b()) && $ISGOOD(c()) ) { 
              tmp += $a() * $b() * $c(); 
              flag = 1;
           }
        %}
        if ( flag ) { $d() = tmp; }
        else        { $SETBAD(d()); }',
       Doc => 
'=for ref

Weighted (i.e. triple) inner product

 d = sum_i a(i) b(i) c(i)

'
       );

pp_def(
       'inner2',
       HandleBad => 1,
       Pars => 'a(n); b(n,m); c(m); [o]d();',
       Code => 
       'double tmp=0;
	loop(n,m) %{
           tmp += $a() * $b() * $c();
        %}
	$d() = tmp;',
       BadCode => 
       'double tmp = 0;
        int flag = 0;
	loop(n,m) %{ 
           if ( $ISGOOD(a()) && $ISGOOD(b()) && $ISGOOD(c()) ) { 
              tmp += $a() * $b() * $c();
              flag = 1;
           }
        %}
        if ( flag ) { $d() = tmp; }
        else        { $SETBAD(d()); }',
       Doc =>
'=for ref

Inner product of two vectors and a matrix

 d = sum_ij a(i) b(i,j) c(j)

Note that you should probably not thread over C<a> and C<c> since that would be  
very wasteful. Instead, you should use a temporary for C<b*c>.

'
       );


pp_def(
       'inner2d',
       HandleBad => 1,
       Pars => 'a(n,m); b(n,m); [o]c();',
       Code => 
       'double tmp=0;
	loop(n,m) %{
           tmp += $a() * $b();
        %}
	$c() = tmp;',
       BadCode => 
       'double tmp = 0;
        int flag = 0;
	loop(n,m) %{ 
           if ( $ISGOOD(a()) && $ISGOOD(b()) ) { 
              tmp += $a() * $b();
              flag = 1;
           }
        %}
        if ( flag ) { $c() = tmp; }
        else        { $SETBAD(c()); }',
       Doc =>
'=for ref

Inner product over 2 dimensions.

Equivalent to

 $c = inner($a->clump(2), $b->clump(2))

'
       );

pp_def(
       'inner2t',
       HandleBad => 1,
       Pars => 'a(j,n); b(n,m); c(m,k); [t]tmp(n,k); [o]d(j,k));',
       Code => 
       'loop(n,k) %{ 
           double tmp0 = 0;
	   loop(m) %{ 
              tmp0 += $b() * $c(); 
           %}
	   $tmp() = tmp0;
	%}
	loop(j,k) %{ 
           double tmp1 = 0;
	   loop(n) %{ 
              tmp1 += $a() * $tmp(); 
           %}
           $d() = tmp1;
	%}',
       BadCode => 
       'loop(n,k) %{ 
           double tmp0 = 0;
           int flag = 0;
	   loop(m) %{ 
              if ( $ISGOOD(b()) && $ISGOOD(c()) ) {
                 tmp0 += $b() * $c(); 
                 flag = 1;
              }
           %}
           if ( flag ) { $tmp() = tmp0; }
           else        { $SETBAD(tmp()); }
	%}
	loop(j,k) %{ 
           double tmp1 = 0;
           int flag = 0;
	   loop(n) %{ 
              if ( $ISGOOD(a()) && $ISGOOD(tmp()) ) {
                 tmp1 += $a() * $tmp(); 
                 flag = 1;
              }
           %}
           if ( flag ) { $d() = tmp1; }
           else        { $SETBAD(d()); }
	%}',
       Doc =>
'=for ref

Efficient Triple matrix product C<a*b*c>

Efficiency comes from by using the temporary C<tmp>. This operation only 
scales as C<N**3> whereas threading using L<inner2|/inner2> would scale 
as C<N**4>.

The reason for having this routine is that you do not need to
have the same thread-dimensions for C<tmp> as for the other arguments,
which in case of large numbers of matrices makes this much more
memory-efficient.

It is hoped that things like this could be taken care of as a kind of
closures at some point.

'
       ); # pp_def inner2t()


# a helper function for the cross product definition
sub crassgn {
  "\$c(tri => $_[0]) = \$a(tri => $_[1])*\$b(tri => $_[2]) -
	\$a(tri => $_[2])*\$b(tri => $_[1]);"
}

pp_def('crossp',
       Doc => <<'EOD',
=for ref

Cross product of two 3D vectors

After

=for example

 $c = crossp $a, $b

the inner product C<$c*$a> and C<$c*$b> will be zero, i.e. C<$c> is
orthogonal to C<$a> and C<$b>

=cut
EOD
       Pars => 'a(tri=3); b(tri); [o] c(tri)',
       Code => 
       crassgn(0,1,2)."\n". 
       crassgn(1,2,0)."\n".
       crassgn(2,0,1),
       );

pp_def('norm',
       HandleBad => 1,
       Pars => 'vec(n); [o] norm(n)',
       Doc => 'Normalises a vector to unit Euclidean length',
       Code => 
       'double sum=0;
	loop(n) %{ sum += $vec()*$vec(); %}
	if (sum > 0) {
	  sum = sqrt(sum);
	  loop(n) %{ $norm() = $vec()/sum; %}
	} else {
	  loop(n) %{ $norm() = $vec(); %}
	}',
       BadCode => 
       'double sum=0;
        int flag = 0;
	loop(n) %{ 
           sum += $vec()*$vec(); 
           flag = 1;
        %}
        if ( flag ) {
	   if (sum > 0) {
	      sum = sqrt(sum);
	      loop(n) %{ 
                 if ( $ISBAD(vec()) ) { $SETBAD(norm()); }
                 else                 { $norm() = $vec()/sum; }
              %}
	   } else {
	      loop(n) %{ 
                 if ( $ISBAD(vec()) ) { $SETBAD(norm()); }
                 else                 { $norm() = $vec(); }
              %}
           }
        } else {
	   loop(n) %{ 
              $SETBAD(norm());
           %}
	}',
);

# this one was motivated by the need to compute
# the circular mean efficiently
# without it could not be done efficiently or without
# creating large intermediates (check pdl-porters for
# discussion)
# see PDL::ImageND for info about the circ_mean function
pp_def(
    'indadd',
    HandleBad => 1,
    Pars => 'a(); int ind(); [o] sum(m)',
    Code => 
    'register int foo = $ind();
     if( foo<0 || foo>=$SIZE(m) ) {
       barf("PDL::indadd: invalid index");
     }
     $sum(m => foo) += $a();',
    BadCode => 
    'register int foo = $ind();
     if( $ISBADVAR(foo,ind) || foo<0 || foo>=$SIZE(m) ) {
       barf("PDL::indadd: invalid index");
     }
     if ( $ISBAD(a()) ) { $SETBAD(sum(m => foo)); }
     else               { $sum(m => foo) += $a(); }',
    BadDoc =>
'The routine barfs if any of the indices are bad.',
    Doc=>'
=for ref

Threaded Index Add: Add C<a> to the C<ind> element of C<sum>, i.e:

 sum(ind) += a

=for example

Simple Example:

  $a = 2;
  $ind = 3;
  $sum = zeroes(10);
  indadd($a,$ind, $sum);
  print $sum
  #Result: ( 2 added to element 3 of $sum)
  # [0 0 0 2 0 0 0 0 0 0]

Threaded Example:

  $a = pdl( 1,2,3);
  $ind = pdl( 1,4,6);
  $sum = zeroes(10);
  indadd($a,$ind, $sum);
  print $sum."\n";
  #Result: ( 1, 2, and 3 added to elements 1,4,6 $sum)
  # [0 1 0 0 2 0 3 0 0 0]

=cut
');

# 1D convolution
# useful for threaded 1D filters
pp_addhdr('
/* Fast Modulus with proper negative behaviour */
#define REALMOD(a,b) while ((a)>=(b)) (a) -= (b); while ((a)<0) (a) += (b); 
');
pp_def('conv1d',
       Doc => << 'EOD',
=for ref

1d convolution along first dimension

=for example

  $con = conv1d sequence(10), pdl(-1,0,1), {Boundary => 'reflect'};

By default, periodic boundary conditions are assumed (i.e. wrap around).
Alternatively, you can request reflective boundary conditions using
the C<Boundary> option:

  {Boundary => 'reflect'} # case in 'reflect' doesn't matter

The convolution is performed along the first dimension. To apply it across
another dimension use the slicing routines, e.g.

  $b = $a->mv(2,0)->conv1d($kernel)->mv(0,2); # along third dim

This function is useful for threaded filtering of 1D signals.

Compare also L<conv2d|PDL::Image2D/conv2d>, L<convolve|PDL::ImageND/convolve>,
L<fftconvolve|PDL::FFT/fftconvolve>, L<fftwconv|PDL::FFTW/fftwconv>,
L<rfftwconv|PDL::FFTW/rfftwconv>

EOD
        Pars => 'a(m); kern(p); [o]b(m);',
        OtherPars => 'int reflect;',
        PMCode => '
        
sub PDL::conv1d {
   my $opt = pop @_ if ref($_[$#_]) eq \'HASH\';
   die \'Usage: conv1d( a(m), kern(p), [o]b(m), {Options} )\'
      if $#_<1 || $#_>2;
   my($a,$kern) = @_;
   my $c = $#_ == 2 ? $_[2] : PDL->null;
   &PDL::_conv1d_int($a,$kern,$c,
		     !(defined $opt && exists $$opt{Boundary}) ? 0 :
		     lc $$opt{Boundary} eq "reflect");
   return $c;
}

',              
        Code => '
           int i,i1,i2,poff;
           double tmp;
           int reflect = $COMP(reflect); 
           int m_size = $COMP(__m_size); 
           int p_size = $COMP(__p_size); 

           poff = (p_size-1)/2;
           for(i=0; i<m_size; i++) { 
              tmp = 0; 
                  for(i1=0; i1<p_size; i1++) { 
                     i2 = i+i1 - poff; 
                     if (reflect && i2<0)
                     	i2 = -i2;
                     if (reflect && i2>=m_size)
                     	i2 = m_size-(i2-m_size+1);

                     REALMOD(i2,m_size); 
                     tmp += $a(m=>i2) * $kern(p=>i1);
                  }
              $b(m=>i) = tmp;
           }
');


# this can be achieved by
#  ($a->dummy(0) == $b)->orover
# but this one avoids a larger intermediate and potentially shortcuts
pp_def('in',
	Pars => 'a(); b(n); [o] c()',
	Code => '$c() = 0;
		 loop(n) %{ if ($a() == $b()) {$c() = 1; break;} %}',
	Doc => <<'EOD',
=for ref

test if a is in the set of values b

=for example

   $goodmsk = $labels->in($goodlabels);
   print pdl(4,3,1)->in(pdl(2,3,3));
  [0 1 0]

C<in> is akin to the I<is an element of> of set theory. In priciple,
PDL threading could be used to achieve its functionality by using a
construct like

   $msk = ($labels->dummy(0) == $goodlabels)->orover;

However, C<in> doesn't create a (potentially large) intermediate
and is generally faster.
EOD
);


pp_add_exported '', 'uniq';
pp_addpm << 'EOPM';

=head2 uniq

=for ref

return all unique elements of a piddle

The unique elements are returned in ascending order.

=for example

  print pdl(2,2,2,4,0,-1,6,6)->uniq;
 [-1 0 2 4 6]

Note: The returned pdl is 1D; any structure of the input
piddle is lost.

=cut

*uniq = \&PDL::uniq;
# return unique elements of array
# find as jumps in the sorted array
# flattens in the process
sub PDL::uniq {
  use PDL::Core 'barf';
  my ($arr) = @_;
  return $arr if($arr->nelem == 0); # The null list is unique (CED)
  my $srt = $arr->clump(-1)->qsort;
  my $uniq = $srt->where($srt != $srt->rotate(-1));
  # make sure we return something if there is only one value
  return $uniq->nelem == 0 ? $srt->index(0)->sever : $uniq;
}

EOPM

#####################################################################
#  clipping routines
#####################################################################

# clipping

for my $opt (
	     ['hclip','>'],
	     ['lclip','<']
	     ) {
    my $name = $opt->[0];
    my $op   = $opt->[1];
    pp_def(
	   $name,
	   HandleBad => 1,
	   Pars => 'a(); b(); [o] c()',
	   Code => 
	   '$c() = ($a() '.$op.' $b()) ? $b() : $a();',
	   BadCode =>
	   'if ( $ISBAD(a()) || $ISBAD(b()) ) {
               $SETBAD(c());
            } else {
	       $c() = ($a() '.$op.' $b()) ? $b() : $a();
            }',
	   Doc =>  'clip C<$a> by C<$b> (C<$b> is '.
	   ($name eq 'hclip' ? 'upper' : 'lower').' bound)',
          PMCode=><<"EOD",
sub PDL::$name {
   my (\$a,\$b) = \@_;
   my \$c;
   if (\$a->is_inplace) {
       \$a->set_inplace(0); \$c = \$a;
   } elsif (\$#_ > 1) {\$c=\$_[2]} else {\$c=PDL->nullcreate(\$a)}
   &PDL::_${name}_int(\$a,\$b,\$c);
   return \$c;
}
EOD
    ); # pp_def $name

} # for: my $opt

pp_add_exported('', 'clip');

pp_addpm(<<'EOD');

=head2 clip

=for ref

Clip a piddle by (optional) upper or lower bounds.

=for usage

 $b = $a->clip(0,3);
 $c = $a->clip(undef, $x);

EOD

    if ( $bvalflag ) {
	pp_addpm(<<'EOD');
=for bad

clip handles bad values since it is just a
wrapper around L<hclip|/hclip> and
L<lclip|/lclip>.

EOD
} # if: $bvalflag

pp_addpm(<<'EOD');
=cut

*clip = \&PDL::clip;
sub PDL::clip {
  my($a, $b, $c) = @_;
  my $d; if($a->is_inplace) {$a->set_inplace(0); $d = $a} 
  elsif($#_ > 2) {$d=$_[3]} else {$d = PDL->nullcreate($a)}
 if(defined $b) {
  	&PDL::_lclip_int($a,$b,$d);
	if(defined $c) {
		&PDL::_hclip_int($d,$c,$d);
	}
  } elsif(defined $c) {
	&PDL::_hclip_int($a,$c,$d);
  }
  return $d;
}

EOD

############################################################
# elementary statistics and histograms
############################################################

pp_def(
       'wtstat',
       HandleBad => 1,
       Pars => 'a(n); wt(n); avg(); [o]b();',
       OtherPars => 'int deg',
       Code =>
       'double wtsum = 0;
	double statsum = 0;
	loop(n) %{
	   register double tmp; 
           register int i;
	   wtsum += $wt();
	   tmp=1; 
           for(i=0; i<$COMP(deg); i++) 
              tmp *= $a();
	   statsum += $wt() * (tmp - $avg()); 
        %}
	$b() = statsum / wtsum;',
       BadCode =>
       'double wtsum = 0;
	double statsum = 0;
        int flag = 0;
	loop(n) %{
           if ( $ISGOOD(wt()) && $ISGOOD(a()) && $ISGOOD(avg()) ) {
              register double tmp; 
              register int i;
	      wtsum += $wt();
	      tmp=1; 
              for(i=0; i<$COMP(deg); i++) 
                 tmp *= $a();
	      statsum += $wt() * (tmp - $avg()); 
              flag = 1;
           }
        %}
        if ( flag ) { $b() = statsum / wtsum; }
        else        { $SETBAD(b()); $PDLSTATESETBAD(b); }',
       CopyBadStatusCode => '',
       Doc => 
'=for ref

Weighted statistical moment of given degree

This calculates a weighted statistic over the vector C<a>.
The formula is

 b() = (sum_i wt_i * (a_i ** degree - avg)) / (sum_i wt_i)

',
       BadDoc => 
'Bad values are ignored in any calculation; C<$b> will only
have its bad flag set if the output contains any bad data.',
       );



pp_def('statsover',
	HandleBad => 1,
	Pars => 'a(n); w(n); int+ [o]avg(); int+ [o]rms(); int+ [o]min(); int+ [o]max(); int+ [o]adev()',
	Code => 
	'$GENERIC(avg) tmp = 0;
         $GENERIC(rms) tmp1 = 0;         
         $GENERIC(adev) tmp2 = 0;
         $GENERIC(rms) diff = 0;
         $GENERIC(min) curmin, curmax;
	 $GENERIC(w) norm = 0;
	 loop(n) %{ 
            tmp += $a()*$w();
            norm += $w();
            if (!n) { curmin = $a(); curmax = $a();}
            if ($a() < curmin) { 
                curmin = $a(); 
             } else if ($a() > curmax) {
                curmax = $a();
             } 
         %}
	 $avg() = tmp / norm;
         $min() = curmin;
         $max() = curmax;
         /* Calculate the RMS using the corrected two-pass algorithm */
         tmp = 0; 
	 loop(n) %{
            diff = ($a()*$w() - $avg());
            tmp += diff*diff;
            tmp1 += diff;
            tmp2 += abs(diff);
         %}
         $rms() = sqrt ( (tmp - tmp1*tmp1/norm)/((norm - ($GENERIC(rms)) 1)) );
         $adev() = sqrt( tmp2/ norm );',
	BadCode => 
	'$GENERIC(avg) tmp = 0;
         $GENERIC(rms) tmp1 = 0;         
         $GENERIC(adev) tmp2 = 0;
         $GENERIC(rms) diff = 0;
         $GENERIC(min) curmin, curmax;
	 $GENERIC(w) norm = 0;
         int flag = 0;
         loop(n) %{
             /* perhaps should check w() for bad values too ? */
             if ( $ISGOOD(a()) ) {
	      tmp += $a()*$w();
              norm += $w();
 	      if (!flag) { curmin = $a(); curmax = $a(); flag=1; }               
              if ($a() < curmin) { 
                curmin = $a(); 
              } else if ($a() > curmax) {
                curmax = $a();
              }
            } 
         %}
         /* have at least one valid point if flag == 1 */
         if ( flag ) { 
           $avg() = tmp / norm;
           $min() = curmin;
           $max() = curmax;
           tmp = 0; 
           loop(n) %{
              if ($ISGOOD(a())) { 
                 diff = ($a()*$w() - $avg());
                 tmp += diff*diff;
                 tmp1 += diff;
                 tmp2 += abs(diff);
              }
           %}
           $rms() = sqrt ( (tmp - tmp1*tmp1/norm)/( (norm - ($GENERIC(rms)) 1)));
           $adev() = sqrt ( tmp2 / norm);
         } else       { 
           $SETBAD(avg()); 
           $SETBAD(rms());
           $SETBAD(adev());
           $SETBAD(min());
           $SETBAD(max());
         }',
      PMCode => '

sub PDL::statsover {
   barf(\'Usage: ($mean,[$rms, $median, $min, $max, $adev]) = statsover($data,[$weights])\') if $#_>1;
   my ($data, $weights) = @_;
   $weights = $data->ones() if !defined($weights);
   
   my $median = $data->medover();
   my $mean = PDL->nullcreate($data);
   my $rms = PDL->nullcreate($data);
   my $min = PDL->nullcreate($data);
   my $max = PDL->nullcreate($data);
   my $adev = PDL->nullcreate($data);
   &PDL::_statsover_int($data, $weights, $mean, $rms, $min, $max, $adev);

   return $mean unless wantarray;
   return ($mean, $rms, $median, $min, $max, $adev);
}

',
      Doc => 
'
=for ref 

Calculate useful statistics over a dimension of a piddle

=for usage

  ($mean, $rms, $median, $min, $max, $adev) = statover($piddle, $weights);

This utility function calculates various useful
quantities of a piddle. These are the mean:

  MEAN = sum (x)/ N

with C<N> being the number of elements in x, the root mean
square deviation from the mean, RMS, given as,

  RMS = sqrt(sum( (x-mean(x))^2 )/(N-1));

Note the use of C<N-1> which for almost all cases should be
the right normalisation factor. The routine also returns 
the median, minimum and maximum of the piddle as well as
the mean absolute deviation, defined as:

  ADEV = sqrt(sum( abs(x-mean(x)) )/N)

note here that we use the mean and not the median. This could
possibly be changed in future versions of the code. 

This operator is a projection operator so the calculation
will take place over the final dimension. Thus if the input 
is N-dimensional each returned value will be N-1 dimensional, 
to calculate the statistics for the entire piddle either
use C<clump(-1)> directly on the piddle or call C<stats>.


',
     BadDoc =>
'
Bad values are simply ignored in the calculation and if all data are
bad the results will also be bad.
',
);

pp_add_exported('','stats');
pp_addpm(<<'EOD');

=head2 stats

=for ref

Calculates useful statistics on a piddle

=for usage

 ($mean,$rms,$median,$min,$max) = stats($piddle,[$weights]);

This utility calculates all the most useful
quantities in one call.

B<Note:> The RMS value that this function returns in the RMS 
deviation from the mean, also known as the population standard-
deviation.

EOD

    if ( $bvalflag ) {
	pp_addpm(<<'EOD');
=for bad

The return values if all elements are bad is currently poorly
defined.

EOD
} # if: bvalflag
pp_addpm(<<'EOD');
=cut

*stats	  = \&PDL::stats;
sub PDL::stats {
    barf('Usage: ($mean,[$rms]) = stats($data,[$weights])') if $#_>1;
    my ($data,$weights) = @_;
    my ($mean,$rms);
    if ($#_==0) {
EOD

    if ( $bvalflag ) {
	pp_addpm(<<'!NO!SUBS!');
	my $npts = $data->ngood;
!NO!SUBS!
} else {
	pp_addpm(<<'!NO!SUBS!');
	my $npts = $data->nelem;
!NO!SUBS!

} # if: $bvalflag

       pp_addpm(<<'EOD');
       if ( $npts == 0 ) {
	   $mean = 0.0; $rms = 0.0;
       } else {
	   $mean = $data->dsum / $npts;
	   $rms  = sqrt( ((($data-$mean)**2 )->dsum) / $npts );
       }
    }
    else {
       my $wtsum = $weights->dsum;
       if ( $wtsum == 0.0 ) {
	   $mean = 0.0; $rms = 0.0;
       } else {
	   $mean = (($weights*$data)->dsum) / $wtsum;
	   $rms = sqrt( ( ( $weights*(($data-$mean)**2) )->dsum )  / $wtsum );
       }
    }
    my ($median,$min,$max) = ($data->median,$data->min,$data->max);
    print "Mean = $mean, RMS = $rms, Median = $median\n".
          "Min  = $min, Max = $max\n" if $PDL::verbose;
    return $mean unless wantarray;
    return ($mean,$rms,$median,$min,$max);
}
EOD

for(
    {Name => 'histogram',
     WeightPar => '',
     HistType => 'int+',
     HistOp => '++',
     Doc1 => "",
     Doc2 => "",
     Doc3 => "number of\n",
     Doc4 => "\nUse L<hist|PDL::Basic/hist> instead for a high-level interface.\n",
     Doc5 => "histogram(pdl(1,1,2),1,0,3)\n [0 2 1]"
     },
    {Name => 'whistogram',
     WeightPar => 'float+ wt(n);',
     HistType => 'float+',
     HistOp => '+= $wt()',
     Doc1 => " from weighted data",
     Doc2 => "\$weights, ",
     Doc3 => "sum of the values in C<\$weights>\nthat correspond to ",
     Doc4 => "",
     Doc5 => "whistogram(pdl(1,1,2), pdl(0.1,0.1,0.5), 1, 0, 4)\n [0 0.2 0.5 0]"
     }
    )
{
pp_def($_->{Name},
       Pars => 'in(n); '.$_->{WeightPar}.$_->{HistType}.  '[o] hist(m)',
       # set outdim by Par!
       OtherPars => 'double step; double min; int msize => m',
       HandleBad => 1,
       Code => 
       'register int j;
	register int maxj = $SIZE(m)-1;
	register double min  = $COMP(min);
	register double step = $COMP(step);
	threadloop %{
	   loop(m) %{ $hist() = 0; %}
	%}
	threadloop %{
	   loop(n) %{
	      j = (int) (($in()-min)/step);
	      if (j<0) j=0;
	      if (j > maxj) j = maxj;
	      ($hist(m => j))'.$_->{HistOp}.';
	   %}
	%}',
       BadCode => 
       'register int j;
	register int maxj = $SIZE(m)-1;
	register double min  = $COMP(min);
	register double step = $COMP(step);
	threadloop %{
	   loop(m) %{ $hist() = 0; %}
	%}
	threadloop %{
	   loop(n) %{
              if ( $ISGOOD(in()) ) {
	         j = (int) (($in()-min)/step);
	         if (j<0) j=0;
	         if (j > maxj) j = maxj;
	         ($hist(m => j))'.$_->{HistOp}.';
              }
	   %}
	%}',
Doc=><<"EOD");

=for ref

Calculates a histogram$_->{Doc1} for given stepsize and minimum.

=for usage

 \$h = $_->{Name}(\$data, $_->{Doc2}\$step, \$min, \$numbins);
 \$hist = zeroes \$numbins;  # Put histogram in existing piddle.
 $_->{Name}(\$data, $_->{Doc2}\$hist, \$step, \$min, \$numbins);

The histogram will contain C<\$numbins> bins starting from C<\$min>, each
C<\$step> wide. The value in each bin is the $_->{Doc3}values in C<\$data> that lie within the bin limits.

Data below the lower limit is put in the first bin, and data above the
upper limit is put in the last bin.

The output is reset in a different threadloop so that you
can take a histogram of C<\$a(10,12)> into C<\$b(15)> and get the result
you want.
$_->{Doc4}

=for example

 perldl> p $_->{Doc5}

EOD
}

for(
    {Name => 'histogram2d',
     WeightPar => '',
     HistType => 'int+',
     HistOp => '++',
     Doc1 => "",
     Doc2 => "",
     Doc3 => "number of\n",
     Doc5 => "histogram2d(pdl(1,1,1,2,2),pdl(2,1,1,1,1),1,0,3,1,0,3)
 [
  [0 0 0]
  [0 2 2]
  [0 1 0]
 ]

"},
    {Name => 'whistogram2d',
     WeightPar => 'float+ wt(n);',
     HistType => 'float+',
     HistOp => '+= $wt()',
     Doc1 => " from weighted data",
     Doc2 => " \$weights,",
     Doc3 => "sum of the values in\nC<\$weights> that correspond to ",
     Doc5 => "whistogram2d(pdl(1,1,1,2,2),pdl(2,1,1,1,1),pdl(0.1,0.2,0.3,0.4,0.5),1,0,3,1,0,3)
 [
  [  0   0   0]
  [  0 0.5 0.9]
  [  0 0.1   0]
 ]

"}
    )
{
pp_def($_->{Name},
       Pars => 'ina(n); inb(n); '.$_->{WeightPar}.$_->{HistType}.  '[o] hist(ma,mb)',
       # set outdim by Par!
       OtherPars => 'double stepa; double mina; int masize => ma;
	             double stepb; double minb; int mbsize => mb;',
       HandleBad => 1,
       Code => 
       'register int ja,jb;
	register int maxja = $SIZE(ma)-1;
	register int maxjb = $SIZE(mb)-1;
	register double mina = $COMP(mina);
	register double minb = $COMP(minb);
	register double stepa = $COMP(stepa);
	register double stepb = $COMP(stepb);
	threadloop %{
	   loop(ma,mb) %{ $hist() = 0; %}
	%}
	threadloop %{
	   loop(n) %{
	      ja = (int) (($ina()-mina)/stepa);
	      jb = (int) (($inb()-minb)/stepb);
	      if (ja<0) ja=0;
	      if (ja > maxja) ja = maxja;
	      if (jb<0) jb=0;
	      if (jb > maxjb) jb = maxjb;
	      ($hist(ma => ja,mb => jb))'.$_->{HistOp}.';
	   %}
	%}
	',
       BadCode => 
       'register int ja,jb;
	register int maxja = $SIZE(ma)-1;
	register int maxjb = $SIZE(mb)-1;
	register double mina = $COMP(mina);
	register double minb = $COMP(minb);
	register double stepa = $COMP(stepa);
	register double stepb = $COMP(stepb);
	threadloop %{
	   loop(ma,mb) %{ $hist() = 0; %}
	%}
	threadloop %{
	   loop(n) %{
              if ( $ISGOOD(ina()) && $ISGOOD(inb()) ) {
	         ja = (int) (($ina()-mina)/stepa);
	         jb = (int) (($inb()-minb)/stepb);
	         if (ja<0) ja=0;
	         if (ja > maxja) ja = maxja;
	         if (jb<0) jb=0;
	         if (jb > maxjb) jb = maxjb;
	         ($hist(ma => ja,mb => jb))'.$_->{HistOp}.';
              }
	   %}
	%}
	',
Doc=><<"EOD");

=for ref

Calculates a 2d histogram$_->{Doc1}.

=for usage

 \$h = $_->{Name}(\$datax, \$datay,$_->{Doc2}
       \$stepx, \$minx, \$nbinx, \$stepy, \$miny, \$nbiny);
 \$hist = zeroes \$nbinx, \$nbiny;  # Put histogram in existing piddle.
 $_->{Name}(\$datax, \$datay,$_->{Doc2} \$hist,
       \$stepx, \$minx, \$nbinx, \$stepy, \$miny, \$nbiny);

The histogram will contain C<\$nbinx> x C<\$nbiny> bins, with the lower
limits of the first one at C<(\$minx, \$miny)>, and with bin size
C<(\$stepx, \$stepy)>. 
The value in each bin is the $_->{Doc3}values in C<\$datax> and C<\$datay> that lie within the bin limits.

Data below the lower limit is put in the first bin, and data above the
upper limit is put in the last bin.

=for example

 perldl> p $_->{Doc5}

EOD
}


###########################################################
# a number of constructors: fibonacci, append, axisvalues &
# random numbers
###########################################################

pp_def('fibonacci',
        Pars => '[o]x(n);',
	Doc=>'Constructor - a vector with Fibonacci\'s sequence',
	PMFunc=>'',
	PMCode=><<'EOD',
sub fibonacci { ref($_[0]) && ref($_[0]) ne 'PDL::Type' ? $_[0]->fibonacci : PDL->fibonacci(@_) }
sub PDL::fibonacci{
   my $class = shift;
   my $x = scalar(@_)? $class->new_from_specification(@_) : $class->new_or_inplace;
   &PDL::_fibonacci_int($x->clump(-1));
   return $x;
}
EOD
     Code => '
        PDL_Long i=0;
        $GENERIC() x1, x2;

        x1 = 1; x2 = 0;

        loop(n) %{
           $x() = x1 + x2;
           if (i++>0) {
              x2 = x1;
              x1 = $x();
           }
        %}
');

pp_def('append',
	Pars => 'a(n); b(m); [o] c(mn)',
# note that ideally we want to say '$SIZE(mn) = $SIZE(m)+$SIZE(n);'
# but that requires placing RedoDimsParsedCode *after* assignment of
# childdims to $SIZE(XXX)!!!  XXXXXmake that workXXXXX
	RedoDimsCode => '
		pdl * dpdla = $PDL(a);
		pdl * dpdlb = $PDL(b);
                $SIZE(mn) = (dpdla->ndims > 0 ? dpdla->dims[0] : 1) + 
                        (dpdlb->ndims > 0 ? dpdlb->dims[0] : 1);
		',
	Code => 'register PDL_Long mnp;
		 PDL_Long ns = $SIZE(n);
                 threadloop %{
                       loop(n) %{ $c(mn => n) = $a(); %}
		       loop(m) %{ mnp = m+ns; $c(mn => mnp) = $b(); %}
		 %}',
	Doc =>
'=for ref

append two or more piddles by concatenating along their first dimensions

=for example

 $a = ones(2,4,7);
 $b = sequence 5;
 $c = $a->append($b);  # size of $c is now (7,4,7) (a jumbo-piddle ;)

C<append> appends two piddles along their first dims. Rest of the dimensions
must be compatible in the threading sense. Resulting size of first dim is
the sum of the sizes of the first dims of the two argument piddles -
ie C<n + m>.

'
   );

pp_addpm(<<'EOD')

=head2 glue

=for usage

  $c = $a->glue(<dim>,$b,...)

=for ref
	
Glue two or more PDLs together along an arbitrary dimension (N-D L<append|append>).

Sticks $a, $b, and all following arguments together using a combination
of xchg() and append().  All other dimensions must be compatible in the 
threading sense.  

C<glue> is implemented in pdl, and should probably be updated (one day) to a 
pure PP function.

=cut

sub PDL::glue{
    my($a) = shift;
    my($dim) = shift;
    if($dim - $a->dim(0) > 100) {
	print STDERR "warning:: PDL::glue allocating >100 dimensions!\n";
    }
    while($dim > $a->ndims) {
	$a = $a->dummy(-1,1);
    }
    $a = $a->xchg(0,$dim);

    while(scalar(@_)){
	my $b = shift;
	while($dim > $b->ndims) {
		$b = $b->dummy(-1,1);
        }
	$b = $b->xchg(0,$dim);
	$a = $a->append($b);
    }
    $a->xchg(0,$dim);
}
	
	
	

EOD
;

pp_def( 'axisvalues',
	Pars => '[o,nc]a(n)',
	Code => 'loop(n) %{ $a() = n; %}',
	Doc => '
=for ref

Internal routine

C<axisvalues> is the internal primitive that implements 
L<axisvals|PDL::Basic/axisvals> 
and alters its argument.

'
       ); # pp_def: axisvalues


pp_addpm(<<'EOD');

=head2 random

=for ref

Constructor which returns piddle of random numbers

=for usage

 $a = random([type], $nx, $ny, $nz,...);
 $a = random $b;

etc (see L<zeroes|PDL::Core/zeroes>).

This is the uniform distribution between 0 and 1 (assumedly
excluding 1 itself). The arguments are the same as C<zeroes>
(q.v.) - i.e. one can specify dimensions, types or give
a template.

You can use the perl function L<srand|perlfunc/srand> to seed the random
generator. For further details consult Perl's  L<srand|perlfunc/srand>
documentation.

=head2 randsym

=for ref

Constructor which returns piddle of random numbers

=for usage

 $a = randsym([type], $nx, $ny, $nz,...);
 $a = randsym $b;

etc (see L<zeroes|PDL::Core/zeroes>).

This is the uniform distribution between 0 and 1 (excluding both 0 and
1, cf L<random|/random>). The arguments are the same as C<zeroes> (q.v.) -
i.e. one can specify dimensions, types or give a template.

You can use the perl function L<srand|perlfunc/srand> to seed the random
generator. For further details consult Perl's  L<srand|perlfunc/srand>
documentation.

=cut
EOD

pp_addhdr(<<'EOH');

#ifndef Drand01
#define Drand01() (((double)rand()) / (RAND_MAX+1.0))
#endif

EOH

pp_def(
	'random',
	Pars=>'a();',
	PMFunc => '',
	Code =>
	'$a() = Drand01();',
	Doc=>undef,
	PMCode=><<'EOD',
sub random { ref($_[0]) && ref($_[0]) ne 'PDL::Type' ? $_[0]->random : PDL->random(@_) }
sub PDL::random {
   my $class = shift;
   my $x = scalar(@_)? $class->new_from_specification(@_) : $class->new_or_inplace;
   &PDL::_random_int($x);
   return $x;
}
EOD
);

pp_def(
	'randsym',
	Pars=>'a();',
	PMFunc => '',
	Code =>
	'double tmp;
	 do tmp = Drand01(); while (tmp == 0.0); /* 0 < tmp < 1 */
         $a() = tmp;',
	Doc=>undef,
	PMCode=><<'EOD',
sub randsym { ref($_[0]) && ref($_[0]) ne 'PDL::Type' ? $_[0]->randsym : PDL->randsym(@_) }
sub PDL::randsym {
   my $class = shift;
   my $x = scalar(@_)? $class->new_from_specification(@_) : $class->new_or_inplace;
   &PDL::_randsym_int($x);
   return $x;
}
EOD
);

pp_addpm(<<'EOD');

=head2 grandom

=for ref

Constructor which returns piddle of Gaussian random numbers

=for usage

 $a = grandom([type], $nx, $ny, $nz,...);
 $a = grandom $b;

etc (see L<zeroes|PDL::Core/zeroes>).

This is generated using the math library routine C<ndtri>.

Mean = 0, Stddev = 1


You can use the perl function L<srand|perlfunc/srand> to seed the random
generator. For further details consult Perl's  L<srand|perlfunc/srand>
documentation.

=cut

sub grandom { ref($_[0]) && ref($_[0]) ne 'PDL::Type' ? $_[0]->grandom : PDL->grandom(@_) }
sub PDL::grandom {
   my $class = shift;
   my $x = scalar(@_)? $class->new_from_specification(@_) : $class->new_or_inplace;
   use PDL::Math 'ndtri';
   $x .= ndtri(randsym($x));
   return $x;
}

EOD

pp_add_exported('','grandom');

###############################################################
# routines somehow related to interpolation
###############################################################

# The last x is ignored...
pp_def('vsearch',
       HandleBad => 0,
       BadDoc => 'needs major (?) work to handles bad values',
	Pars => 'i(); x(n); int [o]ip()',
	GenericTypes => ['F','D'], # too restrictive ?
	Code => 'int carp=0;
		 threadloop %{
		   long n1 = $SIZE(n)-1;
                   long jl=-1, jh=n1, m;
		   int up = ($x(n => n1) > $x(n => 0));
		   $GENERIC() d;
  		   while (jh-jl > 1)  /* binary search */
    			{
      				m = (jh+jl) >> 1;
      				if ($i() > $x(n => m) == up)
					jl = m;
      				else
					jh = m;
    			}
		   if (jl == -1) {
			jh = 0;
                   } else if (jl == n1) {
			if ($i() != $x(n => n1)) carp = 1;
			jh = n1;
		   } else {
			jh = jl+1;
		   }
		   $ip() = jh;
		%}
		if (carp) warn("some values had to be extrapolated");
', Doc=><<'EOD');

=for ref

routine for searching 1D values i.e. step-function interpolation.

=for usage

 $inds = vsearch($vals, $xs);

Returns for each value of C<$vals> the index of the least larger member
of C<$xs> (which need to be in increasing order). If the value is larger
than any member of C<$xs>, the index to the last element of C<$xs> is 
returned.

=for example

This function is useful e.g. when you have a list of probabilities
for events and want to generate indices to events:

 $a = pdl(.01,.86,.93,1); # Barnsley IFS probabilities cumulatively
 $b = random 20;
 $c = vsearch($b, $a); # Now, $c will have the appropriate distr.

It is possible to use the L<cumusumover|/cumusumover> function to obtain
cumulative probabilities from absolute probabilities.

EOD

pp_def('interpolate',
       HandleBad => 0,
       BadDoc => 'needs major (?) work to handles bad values',
	Pars => 'xi(); x(n); y(n); [o] yi(); int [o] err()',
	GenericTypes => ['F','D'], # too restrictive ?
	Code => '
		 $GENERIC() d;
		 long n  = $SIZE(n);
		 long n1 = n-1;
		 int up = ($x(n => n1) > $x(n => 0));
                 long jl, jh, m;
                 int carp;

                 threadloop %{
                   jl = -1;
                   jh = n;
                   carp = 0;
  		   while (jh-jl > 1)  /* binary search */
    			{
      				m = (jh+jl) >> 1;
      				if ($xi() > $x(n => m) == up)
					jl = m;
      				else
					jh = m;
    			}
		   if (jl == -1) {
			if ($xi() != $x(n => 0)) carp = 1;
			jl = 0;
                   } else if (jh == n) {
			if ($xi() != $x(n => n1)) carp = 1;
			jl = n1-1;
		   }
		   jh = jl+1;
		   if ((d = $x(n => jh)-$x(n => jl)) == 0)
			barf("identical abscissas");
		   d = ($x(n => jh)-$xi())/d;
		   $yi() = d*$y(n => jl) + (1-d)*$y(n => jh);
                   $err() = carp;
		%}
', Doc=><<'EOD');

=for ref

routine for 1D linear interpolation

=for usage

 ( $yi, $err ) = interpolate($xi, $x, $y)

Given a set of points C<($x,$y)>, use linear interpolation
to find the values C<$yi> at a set of points C<$xi>.

C<interpolate> uses a binary search to find the suspects, er...,
interpolation indices and therefore abscissas (ie C<$x>)
have to be I<strictly> ordered (increasing or decreasing). 
For interpolation at lots of
closely spaced abscissas an approach that uses the last index found as
a start for the next search can be faster (compare Numerical Recipes
C<hunt> routine). Feel free to implement that on top of the binary
search if you like. For out of bounds values it just does a linear
extrapolation and sets the corresponding element of C<$err> to 1,
which is otherwise 0.

See also L<interpol|/interpol>, which uses the same routine,
differing only in the handling of extrapolation - an error message
is printed rather than returning an error piddle.

=cut
EOD

pp_add_exported('', 'interpol');
pp_addpm(<<'EOD');

=head2 interpol

=for sig

 Signature: (xi(); x(n); y(n); [o] yi())

=for ref

routine for 1D linear interpolation

=for usage

 $yi = interpol($xi, $x, $y)

C<interpol> uses the same search method as L<interpolate|/interpolate>,
hence C<$x> must be I<strictly> ordered (either increasing or decreasing).
The difference occurs in the handling of out-of-bounds values; here
an error message is printed.

=cut

# kept in for backwards compatability
sub interpol ($$$;$) {
    my $xi = shift;
    my $x  = shift;
    my $y  = shift;

    my $yi;
    if ( $#_ == 0 ) { $yi = $_[0]; }
    else            { $yi = PDL->null; }

    interpolate( $xi, $x, $y, $yi, my $err = PDL->null );
    print "some values had to be extrapolated\n"
	if any $err;

    return $yi if $#_ == -1;

} # sub: interpol()
*PDL::interpol = \&interpol;

EOD

pp_add_exported('','interpND');
pp_addpm(<<'EOD');

=head2 interpND 

=for ref 

Interpolate values from an N-D piddle

=for example

  $source = 10*xvals(10,10) + yvals(10,10);
  $index = pdl([[2.2,3.5],[4.1,5.0]],[[6.0,7.4],[8,9]]);
  print $source->interpND( $index );

InterpND acts like L<indexND|indexND>, collapsing C<$index> by lookup
into C<$source>; but it does interpolation, rather than straight
lookup, into C<$source>.  Several options may be passed in via an
options hash. By default, linear or sample interpolation is used, with
constant value outside the boundaries of the source pdl.  No flowback
occurs, because the output is interpolated rather than indexed.

All the interpolation methods treat the pixels as value-centered, so
the C<sample> method will return $a->(0) for coordinate values on 
the set [-0.5,0.5), and the C<linear> method will return $a->(1) for 
a coordinate value of exactly 1.5.


Allowable options:
   
=over 3

=item method 

Values can be:

=over 3 

=item * l, linear, Linear (default for floating point source types)

The values are N-linearly interpolated.

=item * s, sample, Sample (default for integer source types)

The nearest value is taken. Pixels are regarded as centered on their
respective integer coordinates (no offset from the linear case).

=back

=item bound  

This option is passed unmodified into L<indexNDb|indexNDb> as its 
boundary-handling method.  Current allowed values are 'extend', 'periodic', 
and 'truncate'. (default is 'truncate')

=item bad

contains the fill value used for 'truncate' boundary.  (default 0)

=back

=cut
				  
*interpND = *PDL::interpND;
sub PDL::interpND {
  my $source = shift;
  my $index = shift;
  my $options = shift;

  barf 'Usage: interp_nd($source,$index,[{%options}])\n'
    if(defined $options   and    ref $options ne 'HASH');

  my($opt) = (defined $options) ? $options : {};

  my($method)   = $opt->{m} || $opt->{meth} || $opt->{method} || $opt->{Method};
  if(!defined $method) {
	$method = ($source->type <= zeroes(long,1)->type) ? 
	   	   'sample' : 
	           'linear';
  }

  my($boundary) = $opt->{b} || $opt->{boundary} || $opt->{Boundary} || $opt->{bound} || $opt->{Bound} || 'extend';
  my($bad) = $opt->{bad} || $opt->{Bad} || 0.0;

  if($method =~ m/^s(am(p(le)?)?)?/i) {
    return $source->range(PDL::Math::floor($index+0.5),0,$boundary);
  }

  elsif ($method =~ m/^l(in(ear)?)?/i) {
    ## key: (ith = index thread; cth = cube thread; sth = source thread)
    my $d = $index->dim(0);
    my $di = $index->ndims - 1;

    # Grab a 2-on-a-side n-cube around each desired pixel
    my $samp = $source->range($index,2,$boundary); # (ith, cth, sth)

    # Reorder to put the cube dimensions in front and convert to a list
    $samp = $samp->reorder( $di .. $di+$d-1,
			    0 .. $di-1,
			    $di+$d .. $samp->ndims-1) # (cth, ith, sth)
                  ->clump($d); # (clst, ith, sth)

    # Enumerate the corners of an n-cube and convert to a list
    # (the 'x' is the normal perl repeat operator)
    my $crnr = PDL::Basic::ndcoords( (2) x $index->dim(0) ) # (index,cth)
             ->mv(0,-1)->clump($index->dim(0))->mv(-1,0); # (index, clst)

    # a & b are the weighting coefficients.
    my($a,$b);
    {
      my $bb = PDL::Math::floor($index);
      $a = ($index - $bb)     -> dummy(1,$crnr->dim(1)); # index, clst, ith
      $b = ($bb + 1 - $index) -> dummy(1,$crnr->dim(1)); # index, clst, ith
    }

    # Use 1/0 corners to select which multiplier happens, multiply
    # 'em all together to get sample weights, and sum to get the answer.
    my $out =  ( ($a * ($crnr==1) + $b * ($crnr==0)) #index, clst, ith
		 -> prodover                          #clst, ith
		 );

    $out = ($out * $samp)->sumover; # ith, sth

    return $out;
  }  else {
    barf("interpND: unknown method '$method'; valid ones are 'linear' and 'sample'.\n");
  }
}

EOD

##############################################################
# things related to indexing: one2nd, which, where
##############################################################

pp_add_exported("", 'one2nd');
pp_addpm(<<'EOD');

=head2 one2nd

=for ref

Converts a one dimensional index piddle to a set of ND coordinates

=for usage

 @coords=one2nd($a, $indices)

returns an array of piddles containing the ND indexes corresponding to
the one dimensional list indices. The indices are assumed to correspond
to array C<$a> clumped using C<clump(-1)>. This routine is used in 
L<whichND|/whichND>,
but is useful on its own occasionally.

=for example

 perldl> $a=pdl [[[1,2],[-1,1]], [[0,-3],[3,2]]]; $c=$a->clump(-1)
 perldl> $maxind=maximum_ind($c); p $maxind;
 6
 perldl> print one2nd($a, maximum_ind($c))
 0 1 1
 perldl> p $a->at(0,1,1)
 3

=cut

*one2nd = \&PDL::one2nd;
sub PDL::one2nd {
  barf "Usage: one2nd \$array \$indices\n" if $#_ != 1;
  my ($a, $ind)=@_;
  my @dimension=$a->dims;
  my(@index);
  my $count=0;
  foreach (@dimension) {
    $index[$count++]=$ind % $_;
    $ind=long($ind/$_);
  }
  return @index;
}

EOD

my $doc_which = <<'EOD';

=for ref

Returns piddle of indices of non-zero values.

=for usage

 $i = which($mask);

returns a pdl with indices for all those elements that are
nonzero in the mask. Note that the returned indices will be 1D. If you want
to index into the original mask or a similar piddle remember to flatten
it before calling index:

  $data = random 5, 5;
  $idx = which $data > 0.5; # $idx is now 1D
  $bigsum = $data->flat->index($idx)->sum;  # flatten before indexing

Compare also L<where|/where> for similar functionality.

If you want to return both the indices of non-zero values and the
complement, use the function L<which_both|/which_both>.

=for example

 perldl> $x = sequence(10); p $x
 [0 1 2 3 4 5 6 7 8 9]
 perldl> $indx = which($x>6); p $indx
 [7 8 9]

EOD

my $doc_which_both = <<'EOD';

=for ref

Returns piddle of indices of non-zero values and their complement

=for usage

 ($i, $c_i) = which_both($mask);

This works just as L<which|/which>, but the complement of C<$i> will be in
C<$c_i>.

=for example

 perldl> $x = sequence(10); p $x
 [0 1 2 3 4 5 6 7 8 9]
 perldl> ($small, $big) = which_both ($x >= 5); p "$small\n $big"
 [5 6 7 8 9]
 [0 1 2 3 4]

EOD

    for (
	 {Name=>'which',
	  Pars => 'mask(n); int [o] inds(m);',
	  Variables => 'int dm=0;',
	  Elseclause => "",
	  Autosize => '$SIZE(m) = sum;',
	  Doc => $doc_which,
	  PMCode=><<'EOD',
   sub which { my ($this,$out) = @_;
		$this = $this->flat;
		$out = $this->nullcreate unless defined $out;
		PDL::_which_int($this,$out);
		return $out;
   }
   *PDL::which = \&which;
EOD
	  },
	 {Name => 'which_both',
	  Pars => 'mask(n); int [o] inds(m); int [o]notinds(q)',
	  Variables => 'int dm=0; int dm2=0;',
	  Elseclause => "else { \n          \$notinds(q => dm2)=n; \n           dm2++;\n     }",
	  Autosize => '$SIZE(m) = sum;'."\n".'  	  $SIZE(q) = dpdl->dims[0]-sum;',
	  Doc => $doc_which_both,
	  PMCode=><<'EOD',
   sub which_both { my ($this,$outi,$outni) = @_;
		$this = $this->flat;
		$outi = $this->nullcreate unless defined $outi;	
		$outni = $this->nullcreate unless defined $outni;
		PDL::_which_both_int($this,$outi,$outni);
		return wantarray ? ($outi,$outni) : $outi;
   }
   *PDL::which_both = \&which_both;
EOD
	  }
	 )
{
    pp_def($_->{Name},
	   Doc => $_->{Doc},
	   Pars => $_->{Pars},
	   PMCode => $_->{PMCode},
	   Code => $_->{Variables} .
                 'loop(n) %{
			if ($mask()) {
				$inds(m => dm) = n;
				dm++;
			}'.$_->{Elseclause} . "\n".
		' %}',
#		the next one is currently a dirty hack
#               this will probably break once dataflow is enabled again
#               *unless* we have made sure that mask is physical by now!!!
	   RedoDimsCode => '
		PDL_Long sum = 0;
		/* not sure if this is necessary */
		pdl * dpdl = $PDL(mask);
		$GENERIC() *m_datap = (($GENERIC() *)(PDL_REPRP(dpdl)));
		PDL_Long inc = PDL_REPRINC(dpdl,0);
		PDL_Long offs = PDL_REPROFFS(dpdl);
		int i;

		if (dpdl->ndims != 1)
		  barf("dimflag currently works only with 1D pdls");

		for (i=0; i<dpdl->dims[0]; i++) {
		       if ( *(m_datap+inc*i+offs)) sum++;
		}

		'.$_->{Autosize} . '
		/* printf("RedoDimsCode: setting dim m to %ld\n",sum); */'
	   );
}

pp_addpm(<<'EOD'
=head2 where

=for ref

Returns indices to non-zero values or those values from another piddle.

=for usage

 $i = $x->where($x+5 > 0); # $i contains elements of $x
                           # where mask ($x+5 > 0) is 1

Note: C<$i> is always 1-D, even if C<$x> is >1-D. The first argument
(the values) and the second argument (the mask) currently have to have
the same initial dimensions (or horrible things happen).

It is also possible to use the same mask for several piddles with
the same call:

 ($i,$j,$k) = where($x,$y,$z, $x+5>0);

=cut

sub PDL::where {
    barf "Usage: where( \$pdl1, ..., \$pdlN, \$mask )\n" if $#_ == 0;

    if($#_ == 1) {
	my($data,$mask) = @_;
	$data = $_[0]->clump(-1) if $_[0]->getndims>1;
	$mask = $_[1]->clump(-1) if $_[0]->getndims>1;
	return $data->index($mask->which());
    } else {
	if($_[-1]->getndims > 1) {
	    my $mask = $_[-1]->clump(-1)->which;
	    return map {$_->clump(-1)->index($mask)} @_[0..$#_-1];
	} else {
	    my $mask = $_[-1]->which;
	    return map {$_->index($mask)} @_[0..$#_-1];
	}
    }
}
*where = \&PDL::where;

EOD
);

pp_add_exported("", 'where');

pp_addpm(<<'EOD'
=head2 whichND

=for ref

Returns the coordinates for non-zero values. 

=for usage

For historical reasons the return value is different in list and scalar
context.  In scalar context, you get back a PDL containing coordinates suitable
for use in L<indexND|/indexND> or L<range|/range>; in list context, the
coordinates are broken out into separate PDLs.

 $coords = whichND($mask);

returns a PDL containing the coordinates of the elements that are non-zero 
in C<$mask>, suitable for use in indexND.  The 0th dimension contains the
full coordinate listing of each point; the 1st dimension lists all the points.
For example, if $mask has rank 4 and 100 matching elements, then $coords has
dimension 4x100.

 @coords=whichND($mask);

returns a perl list of piddles containing the coordinates of the
elements that are non-zero in C<$mask>.  Each element corresponds to a
particular index dimension.  For example, if $mask has rank 4 and 100
matching elements, then @coords has 4 elements, each of which is a pdl
of size 100.

=for example

 perldl> $a=sequence(10,10,3,4)
 perldl> ($x, $y, $z, $w)=whichND($a == 203); p $x, $y, $z, $w
 [3] [0] [2] [0]
 perldl> print $a->at(list(cat($x,$y,$z,$w)))
 203

=cut

*whichND = \&PDL::whichND;
sub PDL::whichND {
  my $mask = shift;

  # List context: generate a perl list by dimension
  if(wantarray) {
	  my $ind=($mask->clump(-1))->which;
	  return $mask->one2nd($ind);
  } 

  # Scalar context: generate an N-D index piddle


  return null() unless ($mask->getndims);

  $ind = $mask->flat->which->dummy(0,$mask->getndims)->long->make_physical;

  my $mult = ones($mask->getndims)->long;
  my @mdims = $mask->dims;
  my $i;

  for $i(0..$#mdims-1) {
   # use $tmp for 5.005_03 compatibility
   (my $tmp = $mult->index($i+1)) .= $mult->index($i)*$mdims[$i];
  }

  for $i(0..$#mdims) {
   my($s) = $ind->index($i);
   $s /= $mult->index($i);
   $s %= $mdims[$i];
  }

  return $ind;
}

EOD
);

pp_add_exported("", 'whichND');



pp_done();
