<?xml version="1.0"?>
<!-- $Id: libxml.xml,v 1.1 2003/07/17 21:56:18 aa Exp $ -->
<!-- Copyright (c) 2001-2002 AxKit.com. All rights reserved -->
<module name="XML::LibXML">
    <version>1.53</version>
    <authors>
        <author>Matt Sergeant</author>
        <author>Christian Glahn</author>
    </authors>

    <package name="XML::LibXML::DOM">
        <short>XML::LibXML DOM implementation</short>
        <description>
            <p>
                XML::LibXML provides an lightwight interface to <st>modify</st>
                node of the document tree generated by the XML::LibXML
                parser. This interface follows as far as possible the
                DOM Level 3 specification. Additionally to the
                specified functions the XML::LibXML supports some
                functions that are more handy to use in the perl
                environment.
            </p>

            <p>
                One also has to remember, that XML::LibXML is an
                interface to libxml2 nodes which actually reside on
                the C-Level of XML::LibXML. This means each node is a
                reference to a structure different than a perl hash or
                array. The only way to access these structure's values
                is through the DOM interface provided by
                XML::LibXML. This also means, that one <st>can't</st>
                simply inherit a XML::LibXML node and add new member
                variables as they were hash keys.
            </p>

            <p>
                The DOM interface of XML::LibXML does not intend to
                implement a full DOM interface as it is done by
                XML::GDOME and used for full featured
                application. More it offers an simple way to build or
                modify documents that are created by XML::LibXML's
                parser.
            </p>

            <p>
                Another target of the XML::LibXML interface is to make
                the interfaces of libxml2 available to the perl
                community. This includes also some workarounds to
                some features where libxml2 assumes more control over
                the C-Level that most perl users don't have.
            </p>

            <p>
                One of the most important parts of the XML::LibXML DOM
                interface is, that the interfaces try do follow the
                DOM Level 3 specification rather strict. This means
                the interface functions are names as the DOM
                specification says and not what widespread Java
                interfaces claim to be standard. Although there are
                several functions that have only a singular interface
                that is conform to the DOM spec XML::LibXML provides
                an additional Java style alias interface.
            </p>

            <p>
                Also there are some function interfaces left over from
                early stages of XML::LibXML for compatibility
                reasons. These interfaces are for compatibility
                reasons <st>only</st>. They might disappear in one of
                the future versions of XML::LibXML, so a user is
                requested to switch over the official functions.
            </p>

            <p>
                More recent versions of perl (e.g. 5.6.1 or higher)
                support special flags to disinguish between UTF8 and
                so called binary data. XML::LibXML provides for these
                versions functionality to make efficient use of these
                flags: If a document has set an encoding other than
                UTF8 all strings that are not already in UTF8 are
                implicitly encoded from the document encoding to UTF8.
                On output these strings are commonly returned as UTF8
                unless a user does request explicitly the original
                (aka. document) encoding.
            </p>

            <p>
                Older version of perl (such as 5.00503 or less) do not
                support these flags. If XML::LibXML is build for these
                versions, all strings have to get encoded to UTF8
                manualy before they are passed to any DOM functions.
            </p>

            <p>
                <st>NOTE:</st> XML::LibXML's magic encoding may not
                work on all plattforms. Some platforms are known to
                have a broken iconv(), which is partly used by
                libxml2. To test if your platform works correctly with
                your language encoding, build a simple document in the
                particular encoding and try to parse it with
                XML::LibXML.  If your document gets parsed with out
                causing any segmentation faults, bus errors or
                whatever your OS throws. An example for such a test
                can be found in test 19encoding.t of the distribution.
            </p>
            <p>
                <st>Namespaces and XML::LibXML's DOM implementation</st>
            </p>
            <p>
                XML::LibXML's DOM implementation follows the DOM
                implementation of libxml2. This is important to know
                if namespaces are used. Namespaces cannot be declared
                on an document node. This is basicly because XPath
                doesn't know about document nodes. Therefore
                namespaces have to be declared on element nodes. This
                can happen explicitly by using XML::LibXML:Element's
                setNamespace() function or more or less implicitly by
                using XML::LibXML::Document's createElementNS() or
                createAttributeNS() function. If the a namespace is
                not declared on the documentElement, the namespace
                will be localy declared for the newly created node.
                In case of Attributes this may look a bit confusing,
                since these nodes cannot have namespace declarations
                itself. In this case the namespace in internally
                applied to the attribute and later declared on the
                node the attribute is appended to.
            </p>
            <p>
                The following example may explain this a bit:
            </p>
            <example><![CDATA[
 my $doc = XML::LibXML->createDocument;
 my $root = $doc->createElementNS( "", "foo" );
 $doc->setDocumentElement( $root );

 my $attr = $doc->createAttributeNS( "bar", "bar:foo", "test" );
 $root->setAttributeNodeNS( $attr );
                ]]></example>
            <p>
                This piece of code will result the following document:
            </p>
            <example><![CDATA[
 <?xml version="1.0"?>
 <foo xmlns:bar="bar" bar:foo="test"/>
                ]]></example>
            <p>
                Note that the namespace is declared on the document
                element while the setAttributeNodeNS() call.
            </p>

            <p>
                Here it is important to repeat the specification:
                While working with namespaces you should use the
                namespace aware functions instead of the simplified
                versions. For example you should <st>never</st> use
                setAttributeNode() but setAttributeNodeNS().
            </p>
        </description>

        <also>
            <item name="XML::LibXML::Document"/>
            <item name="XML::LibXML::Element"/>
            <item name="XML::LibXML::Node"/>
            <item name="XML::LibXML::Text"/>
            <item name="XML::LibXML::Comment"/>
            <item name="XML::LibXML::CDATASection"/>
            <item name="XML::LibXML::Attr"/>
            <item name="XML::LibXML::DocumentFragment"/>
        </also>
    </package>

    <package name="XML::LibXML::SAX">

        <short>XML::LibXML direct SAX parser</short>

        <description>
            <p>
                XML::LibXML provides an interface to libxml2 direct
                SAX interface. Through this interface it is possible
                to generate SAX events directly while parsing a
                document. While using the SAX parser XML::LibXML will
                not create a DOM Document tree.
            </p>

            <p>
                Such an interface is useful if very large XML
                documents have to be processed and no DOM functions
                are required. By using this interface it is possible
                to read data stored within a XML document directly
                into the application datastructures without loading
                the document into memory.
            </p>

            <p>
                The SAX interface of XML::LibXML is based on the
                famous XML::SAX interface. It uses the generic
                interface as provided by XML::SAX::Base.
            </p>

            <p>
                Additionaly to the generic functions, that are only
                able to process entire documents, XML::LibXML::SAX
                provides <st>parse_chunk()</st>. This method allows to
                generate SAX events from well ballanced data such as
                is often provided by databases.
            </p>

            <p>
                <st>NOTE:</st> At the moment XML::LibXML provides only
                an incomplete interface to libxml2's native SAX
                implementaion. The current implementation is not
                tested in production environment. It may causes
                significant memory problems or shows wrong behaviour.
            </p>

        </description>

        <also>
            <item name="XML::LibXML"/>
            <item name="XML::SAX"/>
            <item name="XML::LibXML::SAX::Parser"/>
            <item name="XML::LibXML::SAX::Builder"/>
        </also>        
    </package>

    <package name="XML::LibXML::Document">
        <short>DOM Document Class</short>
        <description>
            <p>
                The Document Class is in most cases the result of a
                parsing process. But sometimes it is necessary to
                create a Document from scratch. The DOM Document Class
                provides functions that are conform to the DOM Core
                naming style.
            </p>
            <p>
                It inherits all functions from
                <em>XML::LibXML::Node</em> as specified in the DOM
                specification. This enables to access the nodes beside
                the root element on document level - a <em>DTD</em>
                for example. The support for these nodes is limited at
                the moment.
            </p>
            <p>
                While generaly nodes are bound to a document in the DOM
                concept it is suggested that one should always create
                a node not bound to any document. There is no need of
                really including the node to the document, but once
                the node is bound to a document, it is quite safe that
                all strings have the correct encoding.  If an unbound
                textnode with an iso encoded string is created
                (e.g. with $CLASS->new()), the <em>toString</em>
                function may not return the expected result.
            </p>
            <p>
                All this seems like a limitation as long UTF8 encoding
                is ashured. If iso encoded strings come into play it
                is much safer to use the node creation functions of
                <st>XML::LibXML::Document</st>. 
            </p>

            <method name="new" 
                    synopsis="$dom = XML::LibXML::Document->new( $version, $encoding );">
                <p>
                    alias for createDocument()
                </p>
            </method>

            <method name="createDocument" 
                    synopsis="$dom = XML::LibXML::Document->createDocument( $version, $encoding );">
                <p>
                    The constructor for the document class. As
                    Parameter it takes the version string and
                    (optionally) the ecoding string.  Simply calling
                    <st>createDocument</st> will create the document:
                </p>

                <example><![CDATA[
 <?xml version="your version" encoding="your encoding"?>
                    ]]></example>

                <p>
                    Both parameter are optional. The default value for
                    <st>$version</st> is <em>1.0</em>, of course. If
                    the <st>$encoding</st> parameter is not set, the
                    encoding will be left unset, which means UTF8 is
                    implied.
                </p>
                <p>
                    The call of <st>createDocument</st> without any
                    parameter will result the following code:
                </p>
                <example><![CDATA[
 <?xml version="1.0"?>
                    ]]></example>

                <p>
                    Alternatively one can call this constructor
                    directly from the XML::LibXML class level, to
                    avoid some typing. This will not cause any effect
                    to the class instance, which is alway
                    XML::LibXML::Document.
                </p>
                <example><![CDATA[
 my $document = XML::LibXML->createDocument( "1.0", "UTF8" );

is therefore a shortcut for 

 my $document = XML::LibXML::Document->createDocument( "1.0", "UTF8" );
                    ]]></example>
            </method>

            <method name="encoding"
                    synopsis="$strEncoding = $doc->encoding();">
                <p>
                    returns the encoding string of the document.
                </p>
                <example><![CDATA[
 my $doc = XML::LibXML->createDocument( "1.0", "ISO-8859-15" );
 print $doc->encoding; # prints ISO-8859-15
                    ]]></example>
                <p>
                    Optionally this function can be accessed by
                    <st>actualEncoding</st> or <st>getEncoding</st>.
                </p>
            </method>

            <method name="setEncoding" 
                    synopsis="$doc->setEncoding($new_encoding);">
                <p>
                    From time to time it is useful to change the
                    effective encoding of a document. This method
                    provides the interface to manipulate the encoding
                    of a document.
                </p>

                <p>
                    Note that this function has to be used very
                    careful, since you can't simply convert one
                    encoding in any other, since some (or even all)
                    characters may not exist in the new
                    encoding. XML::LibXML will not test if the
                    operation is allowed or possible for the given
                    document. The only switching ashured to work is to
                    UTF8.
                </p>
            </method>

            <method name="version"
                    synopsis="$strVersion = $doc->version();">
                <p>
                    returns the version string of the document
                </p>
                <p>
                    <st>getVersion()</st> is an alternative form of
                    this function.
                </p>
            </method>

            <method name="standalone"
                    synopsis="$doc->standalone">
                <p>
                    This function returns the Numerical value of a
                    documents XML declarations standalone attribute.
                    It returns <st>1</st> if standalone="yes" was
                    found, <st>0</st> if standalone="no" was found and
                    <st>-1</st> if standalone was not specified
                    (default on creation).
                </p>
            </method>

            <method name="setStandalone"
                    synopsis="$doc->setStandalone($numvalue);">
                <p>
                    Through this method it is possible to alter the
                    value of a documents standalone attribute. Set it
                    to <st>1</st> to set standalone="yes", to
                    <st>0</st> to set standalone="no" or set it to
                    <st>-1</st> to remove the standalone attribute
                    from the XML declaration.
                </p>
            </method>

            <method name="compression"
                    synopsis="my $compression = $doc->compression;">
                <p>
                    libxml2 allows to read documents directly from
                    gziped files. In this case the compression
                    variable is set to the compression level of that
                    file (0-8). If XML::LibXML parsed a different
                    source or the file wasn't compressed, the returned
                    value will be <st>-1</st>.
                </p>
            </method>

            <method name="setCompression"
                    synopsis="$doc->setCompression($ziplevel);">
                <p>
                    If one intends to write the document directly to a
                    file, it is possible to set the compression level
                    for a given document. This level can be in the
                    range from 0 to 8. If XML::LibXML should not try
                    to compress use <st>-1</st> (default).
                </p>

                <p>
                    Note that this feature will <st>only</st> work if
                    libxml2 is compiled with zlib support and toFile()
                    is used for output.
                </p>
            </method>


            <method name="toString" 
                    synopsis="$docstring = $dom->toString($format);">
                <p>
                    <st>toString</st> is a deparsing function, so the
                    DOM Tree can be translated into a string, ready
                    for output.
                </p>
                <p>
                    The optional <st>$format</st> parameter sets the
                    indenting of the output. This parameter is
                    expected to be an <em>integer</em> value, that
                    specifies that indentation should be used. The
                    format parameter can have three different values
                    if it is used: 
                </p>
                <p>
                    If $format is 0, than the document is dumped as it
                    was originally parsed
                </p>
                <p>
                    If $format is 1, libxml2 will add ignoreable
                    whitespaces, so the nodes content is easier to read.
                    Existing text nodes will not be altered
                </p>
                <p>
                    If $format is 2 (or higher), libxml2 will act as
                    $format == 1 but it add a leading and a trailing
                    linebreak to each text node.
                </p>
                <p>
                    libxml2 uses a hardcoded indentation of 2 space
                    characters per indentation level. This value can
                    not be altered on runtime.
                </p>
                <p>
                    <st>NOTE</st>: XML::LibXML::Document::toString
                    returns the data in the document encoding rather
                    than UTF8! 
                </p>
            </method>
            
            <method name="toFile"
                    synopsis="$state = $doc->toFile($filename, $format);">
                <p>
                    This function is similar to toString(), but it
                    writes the document directly into a
                    filesystem. This function is very usefull, if one
                    needs to store large documents.
                </p>
                <p>
                     The format parameter has the same behaviour as in
                     toString().
                </p>
            </method>

            <method name="toFH"
                    synopsis="$state = $doc->toFH($fh, $format);">
                <p>
                    This function is similar to toString(), but it
                    writes the document directly to a filehandler or a
                    stream.
                </p>
                <p>
                     The format parameter has the same behaviour as in
                     toString().
                </p>
            </method>

            <method name="toStringHTML"
                    synopsis="$document->toStringHTML();">
                <p>
                    <st>toStringHTML</st> deparses the tree to a
                    string as HTML. With this method indenting is
                    automatic and managed by libxml2 internally.
                </p>
            </method>

            <method name="is_valid" 
                    synopsis="$bool = $dom->is_valid();">
                <p>
                    Returns either TRUE or FALSE depending on the DOM Tree is a
                    valid Document or not.
                </p>
                <p>
                    You may also pass in a XML::LibXML::Dtd object, to
                    validate against an external DTD:
                </p>
                <example>
 if (!$dom->is_valid($dtd)) {
     warn("document is not valid!");
 }
                </example>
            </method>

            <method name="validate"
                    synopsis="$dom->validate();">
                <p>
                    This is an exception throwing equivalent of
                    is_valid. If the document is not valid it will
                    throw an exception containing the error. This
                    allows you much better error reporting than simply
                    is_valid or not.
                </p>
                <p>
                    Again, you may pass in a DTD object
                </p>
            </method>

            <method name="documentElement" 
                    synopsis="$root = $dom->documentElement();">
                <p>
                    Returns the root element of the Document. A
                    document can have just one root element to contain
                    the documents data.
                </p>
                <p>
                    Optionaly one can use <st>getDocumentElement</st>.
                </p>
            </method>

            <method name="setDocumentElement" 
                    synopsis="$dom->setDocumentElement( $root );"> 
                <p>
                    This function enables you to set the root element for a
                    document. The function supports the import of a node from a
                    different document tree.
                </p>
            </method>

            <method name="createElement" 
                    synopsis="$element = $dom->createElement( $nodename );">
                <p>
                    This function creates a new Element Node bound to
                    the DOM with the name <em>$nodename</em>.
                </p>
            </method>

            <method name="createElementNS" 
                    synopsis="$element = $dom->createElementNS( $namespaceURI, $qname );">
                <p>
                    This function creates a new Element Node bound to
                    the DOM with the name <em>$nodename</em> and
                    placed in the given namespace.
                </p>
            </method>

            <method name="createTextNode" 
                    synopsis="$text = $dom->createTextNode( $content_text );">
                <p>
                    As an equivalent of <st>createElement</st>, but it
                    creates a <st>Text Node</st> bound to the DOM.
                </p>
            </method>

            <method name="createComment" 
                    synopsis="$comment = $dom->createComment( $comment_text );">
                <p>
                    As an equivalent of <st>createElement</st>, but it
                    creates a <st>Comment Node</st> bound to the DOM.
                </p>
            </method>

            <method name="createAttribute"
                    synopsis="$attrnode = $doc->createAttribute($name [,$value]);">
                <p>
                    Creates a new Attribute node. 
                </p>
            </method>

            <method name="createDocumentFragment"
                    synopsis="$fragment = $doc->createDocumentFragment()">
                <p>
                    This function creates a DocumentFragment. 
                </p>
            </method>

            <method name="createAttributeNS"
                    synopsis="$attrnode = $doc->createAttributeNS( namespaceURI, $name [,$value] );">
                <p>
                    Creates an Attribute bound to a namespace.
                </p>
            </method>

            <method name="createCDATASection"
                    synopsis="$cdata = $dom->create( $cdata_content );">
                <p>
                    Similar to createTextNode and createComment, this
                    function creates a CDataSection bound to the
                    current DOM.
                </p>
            </method>

            <method name="createProcessingInstruction"
                    synopsis="my $pi = $doc->createProcessingInstruction( $target, $data );">
                <p>
                    create a processing instruction node.
                </p>

                <p>
                    Since this method is quite long one may use its
                    short form <st>createPI()</st>.
                </p>
            </method>

            <method name="createEntityReference"
                    synopsis="my $entref = $doc->createEntityReference($refname);">
                <p>
                    If a docuemnt has a DTD specified, one can create
                    entity refereferences by using this function. If
                    one wants to add a entity reference to the
                    document, this reference has to be created by this
                    function.
                </p>

                <p>
                    An entity reference is unique to a document and
                    cannot passed to other documents as other nodes
                    can be passed. 
                </p>

                <p>
                    <st>NOTE:</st> A text content containing something
                    that looks like an entity reference, will not be
                    expanded to a real entity reference unless it is a
                    predefined entity
                </p>
                
                <example><![CDATA[
 my $string = "&foo;";
 $some_element->appendText( $string );
 print $some_element->textContent; # prints "&amp;foo;"
                    ]]></example>
            </method>

            <method name="createInternalSubset"
                    synopsis="$dtd = $document->createInternalSubset( $rootnode, $public, $system);">
                <p>
                    This function creates and adds an internal subset
                    to the given document. Because the function
                    automaticly adds the DTD to the document there is
                    no need to add the created node explicitly to the
                    document.
                </p>

                <example><![CDATA[
 my $document = XML::LibXML::Document->new();
 my $dtd      = $document->createInternalSubset( "foo", undef, "foo.dtd" );
                    ]]></example>
                <p>
                    will result in the following XML document:
                </p>
                <example><![CDATA[
 <?xml version="1.0"?>
 <!DOCTYPE foo SYSTEM "foo.dtd">
                    ]]></example>

                <p>
                    By setting the public parameter it is possible to
                    set PUBLIC dtds to a given document. So
                </p>
                <example><![CDATA[
 my $document = XML::LibXML::Document->new();
 my $dtd      = $document->createInternalSubset( "foo", "-//FOO//DTD FOO 0.1//EN", undef );

                    ]]></example>
                <p>
                    will cause the following declaration to be created
                    on the document:
                </p>

                <example><![CDATA[
 <?xml version="1.0"?>
 <!DOCTYPE foo PUBLIC "-//FOO//DTD FOO 0.1//EN">
                ]]></example>
           </method>

            <method name="createExternalSubset"
                    synopsis="$dtd = $document->createExternalSubset( $rootnode, $public, $system);">
                <p>
                    This function is similar to
                    <em>createInternalSubset()</em> but this DTD is
                    concidered to be external and is therefore not
                    added to the document itself. Nevertheless it can
                    be used for validation purposes.
                </p>
            </method>

            <method name="importNode"
                    synopsis="$document->importNode( $node );">
                <p>
                    If a node is not part of a document, it can be
                    imported to another document. As specified in DOM
                    Level 2 Specification the Node will not be altered
                    or removed from its original document
                    (<em>$node->cloneNode(1)</em> will get called implicitly).
                </p>
                <p>
                    <st>NOTE:</st> Don't try to use importNode() to import 
                    subtrees that contain an entity reference - even if 
                    the entity reference is the root node of the subtree. 
                    This will cause serious problems to your program. This is
                    a limitation of libxml2 and not of XML::LibXML itself.
                </p>
            </method>

            <method name="adoptNode"
                    synopsis="$document->adoptNode( $node );">
                <p>
                    If a node is not part of a document, it can be
                    imported to another document. As specified in DOM
                    Level 3 Specification the Node will not be altered
                    but it will removed from its original document.
                </p>
                <p>
                    After a document adopted a node, the node, its
                    attributes and all its descendants belong to the
                    new document. Because the node does not belong to
                    the old document, it will be unlinked from its old
                    location first.
                </p>
                <p>
                    <st>NOTE:</st> Don't try to adoptNode() to import
                    subtrees that contain entity references - even if
                    the entity reference is the root node of the
                    subtree. This will cause serious problems to your
                    program. This is a limitation of libxml2 and not
                    of XML::LibXML itself.
                </p>
             </method>

            <method name="externalSubset"
                    synopsis="my $dtd = $doc->externalSubset;">
                <p>
                    If a document has an external subset defined it
                    will be returned by this function.
                </p>
                <p>
                    <st>NOTE</st> Dtd nodes are no ordinary nodes in
                    libxml2. The support for these nodes in
                    XML::LibXML is still limited. In particular one
                    may not want use common node function on doctype
                    declaration nodes!
                </p>
            </method>

            <method name="internalSubset"
                    synopsis="my $dtd = $doc->internalSubset;">
                <p>
                    If a document has an internal subset defined it
                    will be returned by this function.
                </p>
                <p>
                    <st>NOTE</st> Dtd nodes are no ordinary nodes in
                    libxml2. The support for these nodes in
                    XML::LibXML is still limited. In particular one
                    may not want use common node function on doctype
                    declaration nodes!
                </p>
            </method>

            <method name="setExternalSubset"
                    synopsis="$doc->setExternalSubset($dtd);">
                <p><st>EXPERIMENTAL!</st></p>
                <p>
                    This method sets a DTD node as an external subset
                    of the given document.
                </p>
            </method>

            <method name="setInternalSubset"
                    synopsis="$doc->setInternalSubset($dtd);">
                <p><st>EXPERIMENTAL!</st></p>
                <p>
                    This method sets a DTD node as an internal subset
                    of the given document.
                </p>
            </method>

            <method name="removeExternalSubset"
                    synopsis="my $dtd = $doc->removeExternalSubset();">
                <p><st>EXPERIMENTAL!</st></p>
                <p>
                    If a document has an external subset defined it
                    can be removed from the document by using this
                    function. The removed dtd node will be returned.
                </p>
            </method>

            <method name="removeInternalSubset"
                    synopsis="my $dtd = $doc->removeInternalSubset();">
                <p><st>EXPERIMENTAL!</st></p>
                <p>
                    If a document has an internal subset defined it
                    can be removed from the document by using this
                    function. The removed dtd node will be returned.
                </p>
            </method>

            
        </description>
        <also>
            <item name="XML::LibXML"/>
            <item name="XML::LibXML::DOM"/>
            <item name="XML::LibXML::Element"/>
            <item name="XML::LibXML::Text"/>
            <item name="XML::LibXML::Attr"/>
            <item name="XML::LibXML::Comment"/>
            <item name="XML::LibXML::DocumentFragment"/>
            <item name="XML::LibXML::DTD"/>
        </also>
    </package>

    <package name="XML::LibXML::Node">
        <short>abstract Base Class DOM-Nodes</short>
        <description>
            <p>
                LibXML::Node defines functions that are common to all
                Node Types.  A LibXML::Node should never be created
                standalone, but as an instance of a high level class
                such as LibXML::Element or LibXML::Text.  The class
                itself should provide only common functionality. In
                XML::LibXML each node is part either of a document or
                a document-fragment.  Because of this there is no node
                without a parent. This may causes confusion with
                "unbound" nodes.
            </p>


            <method name="nodeName"
                    synopsis="$name = $node->nodeName;">
                <p>
                    Returns the node's name. This Function is aware
                    about namesaces and returns the full name of the
                    current node (<em>prefix:localname</em>)
                </p>
            </method>

            <method name="setNodeName"
                    synopsis="$node->setNodeName( $newName );"> 
                <p>
                    In very limited situation it is usefull to change
                    a nodes name. In the DOM specification this should
                    throw an error. This Function is aware about
                    namespaces.
                </p>
            </method>

            <method name="isSameNode"
                    synopsis="$bool = $node->isSameNode( $other_node );">
                <p>
                    returns TRUE (1) if the given nodes refer to the same
                    node structure, otherwise FALSE (0) is returned.
                </p>
            </method>

            <method name="isEqual"
                    synopsis="$bool = $node->isEqual( $other_node );">
                <p>
                   depraced version of isSameNode().
                </p>
                <p>
                    <st>NOTE</st> isEqual will change behaviour to
                    follow the DOM specification
                </p>
            </method>

            <method name="nodeValue" synopsis="$content = $node->nodeValue;">
                <p>
                    If the node has any content (such as stored in a
                    <em>text node</em>) it can get requested through
                    this function.
                </p>
                <p>
                    <st>NOTE:</st> Element Nodes have no content per
                    definition. To get the text value of an Element
                    use textContent() instead!
                </p>
            </method>

            <method name="textContent" synopsis="$content = $node->textContent;">
                <p>
                    this function returns the content of all text
                    nodes in the descendants of the given node as
                    spacified in DOM.
                </p>
            </method>            

            <method name="nodeType"
                    synopsis="$type = $node->nodeType;">
                <p>
                    Retrun the node's type. The possible types are
                    described in the libxml2 <st>tree.h</st>
                    documentation. The return value of this function
                    is a numeric value. Therefore it differst with the
                    result of perl ref function.
                </p>
            </method>

            <method name="unbindNode" synopsis="$node->unbindNode()"> 
                <p>
                    Unbinds the Node from its siblings and Parent, but
                    not from the Document it belongs to. If the node
                    is not inserted into the DOM afterwards it will be
                    lost after the programm terminated. From a low
                    level view, the unbound node is stripped from the
                    context it is and inserted into a (hidden)
                    document-fragment.
                </p>
            </method>

            <method name="removeChild" 
                    synopsis="$childnode = $node->removeChild( $childnode )">
                <p>
                    This will unbind the Child Node from its parent
                    <em>$node</em>. The function returns the unbound
                    node.  If <em>oldNode</em> is not a child of the
                    given Node the function will fail.
                </p>
            </method>

            <method name="replaceChild" 
                    synopsis="$oldnode = $node->replaceChild( $newNode, $oldNode )">
                <p>
                    Replaces the <em>$oldNode</em> with the
                    <em>$newNode</em>. The <em>$oldNode</em> will be
                    unbound from the Node. This function differs from
                    the DOM L2 specification, in the case, if the new
                    node is not part of the document, the node will be
                    imported first.
                </p>
            </method>

            <method name="replaceNode" synopsis="$node->replaceNode($newNode);">
                <p>
                    This function is very similar to replaceChild(), but it 
                    replaces the node itself rather than a childnode. This is 
                    useful if a node found by any XPath function, should be 
                    replaced.
                </p>
            </method>

            <method name="appendChild"
                    synopsis="$childnode = $node->appendChild( $childnode );">
                <p>
                    The function will add the <em>$childnode</em> to
                    the end of <em>$node</em>'s children. The function
                    should fail, if the new childnode is allready a
                    child of <em>$node</em>. This function differs
                    from the DOM L2 specification, in the case, if the
                    new node is not part of the document, the node
                    will be imported first.
                </p>
            </method>
            <method name="addChild"
                    synopsis="$childnode = $node->addChild( $chilnode );">
                <p>
                    As an alternative to appendChild() one can use the
                    addChild() function. This function is a bit
                    faster, because it avoids all DOM confomity
                    checks. Therefore this function is quite usefull
                    if one builds XML documents in memory where the
                    order and ownership (<em>ownerDocument</em>) is
                    ashured.
                </p>
                <p>
                    addChild() uses libxml2's own xmlAddChild()
                    function. Thus it has to be used with extra care:
                    If a text node is added to a node and the node
                    itself or its last childnode is aswell a text
                    node, the node to add will be merged with the one
                    already available. The current node will be
                    removed from memory after this action. Because
                    perl is not aware about this action, the perl
                    instance is still available. XML::LibXML will
                    catch the loss of a node an avoid to run any
                    function called on that node.
                </p>
                <example><![CDATA[
 my $t1 = $doc->createTextNode( "foo" );
 my $t2 = $doc->createTextNode( "bar" );
 $t1->addChild( $t2 );       # is ok
 my $val = $t2->nodeValue(); # will fail, script dies
                    ]]></example>

                <p>
                    Also addChild() will not check it the added node
                    belongs to the same document as the node it will
                    be added to. This could lead to inconsistent
                    documents and in more worse cases even to memory
                    violations, if one does not keep track of this
                    issue.
                </p>
                <p>
                    Although this sounds like a lot of trouble,
                    addChild() is usefull if a document is build from
                    a stream, such as happens sometimes in SAX
                    handlers or filters.
                </p>
                <p>
                    If you are not shure about the source of your
                    nodes, you better stay with appendChild(), because
                    this function is more user friendly in the sense
                    of more error tolerance.
                </p>
            </method>

            <method name="addNewChild"
                    synopsis="$node = $parent->addNewChild( $nsURI, $name );">
                <p>
                    Similar to <em>addChild()</em>, this function uses
                    low level libxml2 functionality to provide faster
                    interface for DOM building. <st>addNewChild()</st>
                    uses <em>xmlNewChild()</em> to create a new node
                    on a given parent element. 
                </p>
                <p>
                    addNewChild() has two parameters $nsURI and $name,
                    where $nsURI is an (optional) namespace URI. $name
                    is the fully qualified element name; addNewChild()
                    will determine the correct prefix if nessecary.
                </p>
                <p>
                    The function returns the newly created node.
                </p>
                <p>
                    This function is very usefull for DOM building,
                    where a created node can be directly associated to
                    its parent. <st>NOTE</st> this function is not
                    part of the DOM specification and its use will
                    limit your code to XML::LibXML.
                </p>
            </method>

            <method name="addSibling" synopsis="$node->addSibling($newNode);">
                <p>
                    addSibling() allows to add an additional node to
                    the end of a nodelist, defined by the given node.
                </p>
	    </method>

            <method name="cloneNode" 
                    synopsis="$newnode =$node->cloneNode( $deep )">
                <p>
                    <st>cloneNode</st> creates a copy of
                    <em>$node</em>. Wether $deep is set to 1 (true)
                    the function will copy all childnodes as well. If
                    $deep is 0 only the current node will be copied.
                </p>
                <p>
                    <st>cloneNode</st> will not copy any namespace
                    information if it is not run recursivly. 
                </p>
            </method>

            <method name="parentNode"
                    synopsis="$parentnode = $node->parentNode;">
                <p>
                    Returns simply the Parent Node of the current
                    node.
                </p>
            </method>

            <method name="nextSibling" 	
                    synopsis="$nextnode = $node->nextSibling()">
                <p>
                    Returns the next sibling if any .
                </p>
            </method>

            <method name="previousSibling" 	
                    synopsis="$prevnode = $node->previousSibling()">
                <p>
                    Analogous to <st>getNextSibling</st> the function
                    returns the previous sibling if any.
                </p>
            </method>

            <method name="hasChildNodes"
                    synopsis="$boolean = $node->hasChildNodes();"> 
                <p>
                    If the current node has Childnodes this function
                    returns TRUE (1), otherwise it returns FALSE (0,
                    not undef).
                </p>
            </method>

            <method name="firstChild"
                    synopsis="$childnode = $node->firstChild;">
                <p>
                    If a node has childnodes this function will return
                    the first node in the childlist.
                </p>
            </method>

            <method name="lastChild" synopsis="$childnode = $node->lastChild;">
                <p>
                    If the <em>$node</em> has childnodes this function
                    returns the last child node.
                </p>
            </method>
            <method name="ownerDocument"
                    synopsis="$documentnode = $node->ownerDocument;">
                <p>
                    Through this function it is allways possible to
                    access the document the current node is bound to.
                </p>
            </method>

            <method name="getOwner"
                    synopsis="$node = $node->getOwner;">
                <p>
                    This function returns the node the current node is
                    associated with. In the very most cases this will
                    be a document node or a document fragment node.
                </p>
            </method>

            <method name="setOwnerDocument" 
                    synopsis="$node->setOwnerDocument( $doc );">
                <p>
                    This function binds a node to another DOM. This
                    method unbinds the node first, if it is allready
                    bound to another document.
                </p>
                <p>
                    This function is the oposite calling of
                    XML::LibXML::Document's adoptNode()
                    function. Because of this it has the same
                    limitations with Entity References as adoptNode().
                </p>
            </method>

            <method name="insertBefore" 
                    synopsis="$node->insertBefore( $newNode, $refNode )"> 
                <p>
                    The method inserts <em>$newNode</em> before
                    <em>$refNode</em>. If <em>$refNode</em> is
                    undefined, the newNode will be set as the new
                    first child of the parent node.  This function
                    differs from the DOM L2 specification, in the
                    case, if the new node is not part of the document,
                    the node will be imported first.
                </p>
            </method>

            <method name="insertAfter"
                    synopsis="$node->insertAfter( $newNode, $refNode )">
                <p>
                    The method inserts <em>$newNode</em> after
                    <em>$refNode</em>. If <em>$refNode</em> is
                    undefined, the newNode will be set as the new last
                    child of the parent node.
                </p>
            </method>

            <method name="findnodes" 
                    synopsis="@nodes = $node->findnodes( $xpath_statement );">
                <p>
                    <st>findnodes</st> performs the xpath statement on
                    the current node and returns the result as an
                    array. In scalar context returns a
                    <em>XML::LibXML::NodeList</em> object.
                </p>
            </method>

            <method name="find"
                    synopsis="$result = $node->find( $xpath );">
                <p>
                    <st>find</st> performs the xpath expression using
                    the current node as the context of the expression,
                    and returns the result depending on what type of
                    result the XPath expression had. For example, the
                    XPath "1 * 3 + 52" results in a
                    <em>XML::LibXML::Number</em> object being
                    returned. Other expressions might return a
                    <em>XML::LibXML::Boolean</em> object, or a
                    <em>XML::LibXML::Literal</em> object (a
                    string). Each of those objects uses Perl's
                    overload feature to "do the right thing" in
                    different contexts.
                </p>
            </method>

            <method name="findvalue"
                    synopsis="print $node->findvalue( $xpath );">
                <p>
                    <st>findvalue</st> is exactly equivalent to:
                </p>
                <example><![CDATA[
 $node->find( $xpath )->to_literal;
                ]]></example>
                <p>
                    That is, it returns the literal value of the
                    results. This enables you to ensure that you get a
                    string back from your search, allowing certain
                    shortcuts. This could be used as the equivalent of
                    XSLT's <![CDATA[<xsl:value-of select="some_xpath"/>]]>.
                </p>
            </method>

            <method name="childNodes"
                    synopsis="@childnodes = $node->childNodes;">
                <p>
                    <st>getChildnodes</st> implements a more intuitive
                    interface to the childnodes of the current
                    node. It enables you to pass all children directly
                    to a <em>map</em> or <em>grep</em>. If this
                    function is called in scalar context, a
                    <em>XML::LibXML::NodeList</em> object will be
                    returned.
                </p>
            </method>

            <method name="toString"
                    synopsis="$xmlstring = $node->toString($format,$docencoding);">
                <p>
                    This is the equivalent to
                    <em>XML::LibXML::Document::toString</em> for a
                    single node. This means a node and all its
                    childnodes will be dumped into the result string.
                </p>

                <p>
                    Additionally to the $format flag of
                    XML::LibXML::Document, this version accepts the
                    optional $docencoding flag. If this flag is set
                    this function returns the string in its original
                    encoding (the encoding of the document) rather
                    than UTF8.
                </p>
            </method>

            <method name="localname" synopsis="$localname = $node->localname;">                <p>
                    Returns the local name of a tag. This is the part
                    behind the colon.
                </p>
            </method>

            <method name="prefix" synopsis="$nameprefix = $node->prefix;">
                <p>
                    Returns the prefix of a tag. This is the part
                    before the colon.
                </p>
            </method>

            <method name="namespaceURI"
                    synopsis="$uri = $node->namespaceURI()">
                <p>
                    returns the URI of the current namespace.
                </p>
            </method>


            <method name="hasAttributes"
                    synopsis="$boolean = $node->hasAttributes();">
                <p>
                    returns 1 (TRUE) if the current node has any
                    attributes set, otherwise 0 (FALSE) is returned.
                </p>
            </method>



            <method name="attributes" 
                    synopsis="@attributelist = $node->attributes();">
                <p>

                    This function returns all attributes and namespace
                    declarations assigned to the given node.
                </p>
                <p>
                    Because XML::LibXML does not implement namespace
                    declarations and attributes the same way, it is
                    required to test what kind of node is handled
                    while accessing the functions result.
                </p>
                <p>
                    If this function is called in array context the
                    attribute nodes are returned as an array. In
                    scalar context the function will return a
                    <em>XML::LibXML::NamedNodeMap</em> object.
                </p>
            </method>

            <method name="lookupNamespaceURI"
                    synopsis="$URI = $node->lookupNamespaceURI( $prefix );">
                <p>
                    Find a namespace URI by its prefix starting at the
                    current node.
                </p>
            </method>

            <method name="lookupNamespacePrefix"
                    synopsis="$prefix = $node->lookupNamespacePrefix( $URI );">
                <p>
                    Find a namespace prefix by its URI starting at the
                    current node.
                </p>
                <p>
                    <st>NOTE</st> Only the namespace URIs are ment to be
                    unique. The prefix is only document related. also 
                    document might has more than a single prefix defined 
                    for a namespace.
                </p>
            </method>

            <method name="iterator"
                    synopsis="$iter = $node->iterator;">
                <p>
                   This function returns a new iterator object based
                   with the current element as first element. This
                   iterator can be used for linear tree walking.
                </p>

                <example><![CDATA[
 $node->iterator->iterate( sub { shift;print $_[0]->nodeName(),"\n"; } );
                ]]></example>

                <p>
                    The example will print all node names in the
                    current subtree.
                </p>

                <p>
                   Check the <em>XML::LibXML::Iterator</em> man page
                   for more details.
                </p>

                <p>
                    <st>NOTE:</st> The function has changed with
                    version 1.53. Earlier versions did not return an
                    iterator object, but ran the iterate() function
                    directly.
                </p>
            </method>

            <method name="normalize" synopsis="$node->normalize;">
                 <p>
                   This function normalizes adjacent textnodes. This
                   function is not as strict as libxml2's
                   xmlTextMerge() function, since it will not free a
                   node that is still refered by the perl layer.
                 </p>
            </method>

            <method name="getNamespaces" synopsis="@nslist = $node->getNamespaces;">
                <p>
                    If a node has any namespaces defined, this
                    function will return these namespaces. Note, that
                    this will not return all namespaces that are in
                    scope, but only the ones declares explicitly for
                    that node.
                </p>
                <p>
                    Although getNamespaces is available for all nodes,
                    it makes only sense if used with element nodes.
                </p>
            </method>

            <method name="removeChildNodes" synopsis="$node->removeChildNodes();">
                <p>
                    This function is not specified for any DOM level:
                    It removes all childnodes from a node in a single
                    step.  Other than the libxml2 function itself
                    (xmlFreeNodeList), this function will not
                    imediatly remove the nodes from the memory. This
                    safes one from getting memory violations, if there are 
                    nodes still refered from the Perl level. 
                </p>
            </method>

        </description>
        <also>
            <item name="XML::LibXML"/>
            <item name="XML::LibXML::Element"/>
            <item name="XML::LibXML::Text"/>
            <item name="XML::LibXML::Comment"/>
            <item name="XML::LibXML::Attr"/>
            <item name="XML::LibXML::DocumentFragment"/>
        </also>
    </package>

    <package name="XML::LibXML::Element">
        <short>The DOM Element Class</short>
        <description>

            <method name="new"
                    synopsis="$node = XML::LibXML::Element->new( $name )">
                <p>
                    This function creates a new node unbound to any DOM.
                </p>
            </method>

            <method name="setAttribute"
                    synopsis="$node->setAttribute( $aname, $avalue );">
                <p>
                    This method sets or replaces the node's attribute
                    <em>$aname</em> to the value <em>$avalue</em>
                </p>
            </method>

            <method name="setAttributeNS"
                    synopsis="$node->setAttributeNS( $nsURI, $aname, $avalue );">
                <p>
                    Namespaceversion of <em>setAttribute</em>.
                </p>
            </method>

            <method name="getAttribute" 
                    synopsis="$avalue = $node->getAttribute( $aname );">
                <p>
                    If <em>$node</em> has an attribute with the name
                    <em>$aname</em>, the value of this attribute will
                    get returned.
                </p>
            </method>

            <method name="getAttributeNS"
                    synopsis="$avalue = $node->setAttributeNS( $nsURI, $aname );">
                <p>
                    Namespaceversion of <em>getAttribute</em>.
                </p>
            </method>

            <method name="getAttributeNode"
                    synopsis="$attrnode = $node->getAttributeNode( $aname );">
                <p>
                    Returns the attribute as a node if the attribute
                    exists. If the Attribute does not exists
                    <em>undef</em> will be returned.
                </p>
            </method>

            <method name="getAttributeNodeNS"
                    synopsis="$attrnode = $node->getAttributeNodeNS( $namespaceURI, $aname );">
                <p>
                    Namespaceversion of <em>getAttributeNode</em>. 
                </p>
            </method>

            <method name="removeAttribute"
                    synopsis="$node->removeAttribute( $aname );">
                <p>
                    The method removes the attribute <em>$aname</em>
                    from the node's attribute list, if the attribute
                    can be found.
                </p>
            </method>

            <method name="removeAttributeNS"
                    synopsis="$node->removeAttributeNS( $nsURI, $aname );">
                <p>
                    Namespace version of <em>removeAttribute</em>
                </p>
            </method>

            <method name="hasAttribute"
                    synopsis="$boolean = $node->hasAttribute( $aname );">
                <p>
                    This funcion tests if the named attribute is set
                    for the node. If the attribute is specified, TRUE
                    (1) will be returned, otherwise the returnvalue is
                    FALSE (0).
                </p>
            </method>

            <method name="hasAttributeNS"
                    synopsis="$boolean = $node->hasAttributeNS( $nsURI, $aname );">
                <p>
                    namespace version of <em>hasAttribute</em>
                </p>
            </method>

            <method name="getChildrenByTagName" 
                    synopsis="@nodes = $node->getChildrenByTagName($tagname);">
                <p>
                    The function gives direct access to all childnodes
                    of the current node with the same tagname. It
                    makes things a lot easier if you need to handle
                    big datasets.
                </p>
                <p>
                    If this function is called in SCALAR context, it
                    returns the number of Elements found.
                </p>
            </method>

            <method name="getChildrenByTagNameNS" 
                    synopsis="@nodes = $node->getChildrenByTagNameNS($nsURI,$tagname);">
                <p>
                    Namespace version of <em>getChildrenByTagName</em>.
                </p>
                <p>
                    If this function is called in SCALAR context, it
                    returns the number of Elements found.
                </p>
            </method>

            <method name="getElementsByTagName"
                    synopsis="@nodes = $node->;getElementsByTagName($tagname);">
                <p>
                    This function is part of the spec it fetches all
                    descendants of a node with a given tagname. If one
                    is as confused with <em>tagname</em> as I was,
                    tagname is a qualified tagname which is in case of
                    namespace useage prefix and local name
                </p>
                <p>
                    In SCALAR context this function returns a
                    <em>XML::LibXML::NodeList</em> object.
                </p>
            </method>

            <method name="getElementsByTagNameNS" 
                    synopsis="@nodes = $node->getElementsByTagNameNS($nsURI,$localname);">
                <p>
                    Namespace version of <em>getElementsByTagName</em>
                    as found in the DOM spec.
                </p>
                <p>
                    In SCALAR context this function returns a
                    <em>XML::LibXML::NodeList</em> object.
                </p>
            </method>

            <method name="getElementsByLocalName" 
                    synopsis="@nodes = $node->getElementsByLocalName($localname);">
                <p>
                    This function is not found in the DOM
                    specification. It is a mix of getElementsByTagName
                    and getElementsByTagNameNS. It will fetch all tags
                    matching the given local-name. This alows one to
                    select tags with the same local name across
                    namespace borders.
                </p>
                <p>
                    In SCALAR context this function returns a
                    <em>XML::LibXML::NodeList</em> object.
                </p>
            </method>

            <method name="appendWellBalancedChunk" 
                    synopsis="$node->appendWellBalancedChunk( $chunk )">
                <p>
                    Sometimes it is nessecary to append a string coded
                    XML Tree to a
                    node. <st>appendWellBalancedChunk</st> will do the
                    trick for you.  But this is only done if the
                    String is <em>well-balanced</em>.
                </p>
   		<p>
 		    <st>Note that appendWellBalancedChunk() is only left for
		    compatibility reasons</st>. Implicitly it uses 
		</p>
<example><![CDATA[
  my $fragment = $parser->parse_xml_chunk( $chunk );
  $node->appendChild( $fragment );
]]></example>
 		<p>
		    This form is more explicit and makes it easier to 
		    control the flow of a script. 
		</p>
            </method>

            <method name="appendText" 
                    synopsis="$node->appendText( $PCDATA );">
                <p>
                    alias for appendTextNode().
                </p>
            </method>

            <method name="appendTextNode"
                    synopsis="$node->appendTextNode( $PCDATA );">
                <p>
                    This wrapper function lets you add a string
                    directly to an element node.
                </p>
            </method>

            <method name="appendTextChild" 
                    synopsis="$node->appendTextChild( $childname , $PCDATA )">
                <p>
                    Somewhat similar with <em>appendTextNode</em>: It
                    lets you set an Element, that contains only a
                    <em>text node</em> directly by specifying the name
                    and the text content.
                </p>
            </method>

            <method name="setNamespace" 
                    synopsis="$node->setNamespace( $nsURI , $nsPrefix, $activate )">
                <p>
                    setNamespace() allows one to apply a namespace to
                    an element. The function takes three parameters:
                    1. the namespace URI, which is required and the
                    two optional values prefix, which is the namespace
                    prefix, as it should be used in child elements or
                    attributes as well as the additionally activate
                    parameter.
                </p>
                <p>
                    The activate parameter is most usefull: If this
                    parameter is set to FALSE (0), the namespace is
                    simply added to the namespacelist of the node,
                    while the element's namespace itself is not
                    altered. Nevertheless activate is set to TRUE (1)
                    on default. In this case the namespace automaticly
                    is used as the nodes effective namespace. This
                    means the namespace prefix is added to the node
                    name and if there was a namespace already active
                    for the node, this will be replaced (but not
                    removed from the global namespace list)
                </p>

                <p>
                    The following example may clarify this:
                </p>

                <example><![CDATA[
 my $e1 = $doc->createElement("bar");
 $e1->setNamespace("http://foobar.org", "foo")
                ]]></example>

                <p>
                   results
                </p>

 <example><![CDATA[
 <foo:bar xmlns:foo="http://foobar.org"/>
]]></example>

                <p>
                    while 
                </p>

                <example><![CDATA[
 my $e2 = $doc->createElement("bar");
 $e2->setNamespace("http://foobar.org", "foo",0)
                ]]></example>
                <p>
                   results only
                </p>

 <example><![CDATA[
 <bar xmlns:foo="http://foobar.org"/>
]]></example>

                <p>
                    By using $activate == 0 it is possible to apply
                    multiple namepace declarations to a single
                    element.
                </p>

                <p>
                    Alternativly you can call setAttribute() simply to
                    declare a new namespace for a node, without
                    activating it:
                </p>

                <example><![CDATA[
  $e2->setAttribute( "xmlns:foo", "http://bar.org" );                 
                ]]></example>

                <p>
                    has the same result as
                </p>

                <example><![CDATA[
 $e2->setNamespace("http://foobar.org", "foo", 0)
                ]]></example>
            </method>

        </description>
        <also>
            <item name="XML::LibXML"/>
            <item name="XML::LibXML::Node"/>
            <item name="XML::LibXML::Document"/>
            <item name="XML::LibXML::Attr"/>
            <item name="XML::LibXML::Text"/>
            <item name="XML::LibXML::Comment"/>
            <item name="XML::LibXML::DocumentFragment"/>
        </also>
    </package>

    <package name="XML::LibXML::Text">
        <short>The DOM Text Node Class</short>
        <description>
            <p>
                Different to the DOM specification XML::LibXML
                implements the text node as the base class of all
                character data node. Therefor there exists no
                CharacterData class. This allow one to use all methods
                that are available for textnodes as well for Comments
                or CDATA-sections.
            </p>

            <method name="new"
                    synopsis="$text = XML::LibXML::Text->new( $content ); ">
                <p>
                    The constuctor of the class. It creates an unbound text node.
                </p>
            </method>

            <method name="data"
                    synopsis="$nodedata = $text->data;">
                <p>
                    Although there exists the <em>nodeValue</em>
                    attribute in the Node class, the DOM specification
                    defines data as a separate
                    attribute. <em>XML::LibXML</em> implements these
                    two attributes not as different attributes, but as
                    aliases, such as <em>libxml2</em> does. Therefore 
                </p>
                <example><![CDATA[
 $text->data
                ]]></example>
                <p>and</p>
                <example><![CDATA[
 $text->nodeValue
                ]]></example>
                <p>
                    will have the same result and are not different
                    entities.
                </p>
            </method>

            <method name="setData($string)"
                    synopsis="$text->setData( $text_content );">
                <p>
                    This function sets or replaces text content to a
                    node. The node has to be of the type "text",
                    "cdata" or "comment".
                </p>
            </method>

            <method name="substringData($offset,$length)"
                    synopsis="$text->substringData($offset, $length);">
                <p>
                    Extracts a range of data from the node. (DOM Spec)
                    This function takes the two parameters $offset and
                    $length and returns the substring if available.
                </p>
                <p>
                    If the node contains no data or $offset referes to
                    an nonexisting string index, this function will
                    return <st>undef</st>. If $length is out of range
                    <em>substringData</em> will return the data
                    starting at $offset instead of causing an error.
                </p>
            </method>

            <method name="appendData($string)"
                    synopsis="$text->appendData( $somedata );">
                <p>
                    Appends a string to the end of the existing
                    data. If the current text node contains no data,
                    this function has the same effect as
                    <em>setData</em>.
                </p>
            </method>

            <method name="insertData($offset,$string)"
                    synopsis="$text->insertData($offset, $string);">
                <p>
                    Inserts the parameter $string at the given $offset
                    of the existing data of the node. This operation
                    will not remove existing data, but change the
                    order of the existing data.
                </p>
                <p>
                    The $offset has to be a positive value. If $offset
                    is out of range, <em>insertData</em> will have the
                    same behaviour as <em>appendData</em>.
                </p>
            </method>

            <method name="deleteData($offset, $length)"
                    synopsis="$text->deleteData($offset, $length);">
                <p>
                    This method removes a chunk from the existing node
                    data at the given offset. The $length parameter
                    tells, how many characters should be removed from
                    the string.
                </p>
            </method>

            <method name="deleteDataString($string, [$all])"
                    synopsis="$text->deleteDataString($remstring, $all);">
                <p>
                    This method removes a chunk from the existing node
                    data. Since the DOM spec is quite unhandy if you
                    already know <em>which</em> string to remove from
                    a text node, this method allows more perlish code :)
                </p>
                <p>
                    The functions takes two parameters:
                    <st>$string</st> and optional the <st>$all</st>
                    flag. If $all is not set, <st>undef</st> or
                    <st>0</st>, <em>deleteDataString</em> will remove
                    only the first occourance of $string. If $all is
                    <st>TRUE</st> <em>deleteDataString</em> will
                    remove all occourences of <st>$string</st> from
                    the node data.
                </p>
            </method>

            <method name="replaceData($offset, $length, $string)"
                    synopsis="$text->replaceData($offset, $length, $string);">
                <p>
                    The DOM style version to replace node data.
                </p>
            </method>

            <method name="replaceDataString($oldstring, $newstring, [$all])"
                    synopsis="$text->replaceDataString($old, $new, $flag);">
                <p>
                    The more programmer friendly version of replaceData() :)
                </p>
                <p>
                    Instead of giving offsets and length one can
                    specify the exact string (<st>$oldstring</st>) to
                    be replaced. Additionally the <st>$all</st> flag
                    allows to replace all occourences of
                    <st>$oldstring</st>.
                </p>
            </method>
            
            <method name="replaceDataRegEx( $search_cond, $replace_cond, $reflags )"
                    synopsis="$text->replaceDataRegEx( $search_cond, $replace_cond, $reflags );">
                <p>
                    This method replaces the node's data by a
                    <em>simple</em> regular expression. Optional, this
                    function allows to pass some flags that will be
                    added as flag to the replace statement.
                </p>
                <p>
                    <st>NOTE:</st> This is a shortcut for
                </p>
                <example><![CDATA[
 my $datastr = $node->getData();
 $datastr =~ s/somecond/replacement/g; # 'g' is just an example for any flag
 $node->setData( $datastr );
                    ]]></example>

                <p>
                    This function can make things easier to read for
                    simple replacements. For more complex variants it
                    is recommented to use the code snippet above.
                </p>
            </method>

        </description>
        <also>
            <item name="XML::LibXML"/>
            <item name="XML::LibXML::Node"/>
            <item name="XML::LibXML::Element"/>
            <item name="XML::LibXML::Document"/>
            <item name="XML::LibXML::Comment"/>
            <item name="XML::LibXML::DocumentFragment"/>
        </also>
    </package>

    <package name="XML::LibXML::Comment">
        <short>The DOM Comment Class</short>
        <description>
            <p>
                This class provides all functions of
                <st>XML::LibXML::Text</st>, but for comment
                nodes. This can be done, since only the output of the
                nodetypes is different, but not the datastructure. :-)
            </p>

            <method name="new" synopsis="$node = XML::LibXML::Comment( $content );">
                <p>
                    The constructor is the only provided function for
                    this package. It is required, because
                    <st>libxml2</st> treats text nodes and comment
                    nodes slightly different.
                </p>
            </method>

        </description>
        <also>
            <item name="XML::LibXML"/>
            <item name="XML::LibXML::Node"/>
            <item name="XML::LibXML::Element"/>
            <item name="XML::LibXML::Text"/>
            <item name="XML::LibXML::Document"/>
            <item name="XML::LibXML::DocumentFragment"/>
        </also>
    </package>

    <package name="XML::LibXML::CDATASection">
        <short>The DOM CDATASection Class</short>
        <description>
            <p>
                This class provides all functions of
                <st>XML::LibXML::Text</st>, but for CDATA nodes.
            </p>
           
            <method name="new" synopsis="$node = XML::LibXML::Comment( $content );">
                <p>
                    The constructor is the only provided function for
                    this package. It is required, because
                    <st>libxml2</st> treats the different textnode
                    types slightly different.
                </p>
            </method>

        </description>
        <also>
            <item name="XML::LibXML"/>
            <item name="XML::LibXML::Node"/>
            <item name="XML::LibXML::Element"/>
            <item name="XML::LibXML::Text"/>
            <item name="XML::LibXML::Document"/>
            <item name="XML::LibXML::DocumentFragment"/>
        </also>
    </package>

    <package name="XML::LibXML::Attr">
        <short>The DOM Attribute Class</short>
        <description>
            <p>
                This is the interface to handle Attributes like
                ordinary nodes. The naming of the class relies on the
                W3C DOM documentation.
            </p>

            <method name="new" 
                    synopsis="$attr = XML::LibXML::Attr->new($name [,$value]);">
                <p>
                    Class constructor. If you need to work with iso
                    encoded strings, you should <st>allways</st> use
                    the <em>createAttrbute</em> of
                    <st>XML::LibXML::Document</st>.
                </p>
            </method>

            <method name="getValue" synopsis="$string = $attr->getValue();">
                <p>
                    Returns the value stored for the attribute. If
                    undef is returned, the attribute has no value,
                    which is different of being <em>not
                    specified</em>.
                </p>
            </method>


            <method name="value" synopsis="$value = $attr->value;">
                <p>
                    Alias for <st>getValue()</st>
                </p>
            </method>


            <method name="setValue" synopsis="$attr->setValue( $string );">
                <p>
                    This is needed to set a new attributevalue. If iso
                    encoded strings are passed as parameter, the node
                    has to be bound to a document, otherwise the
                    encoding might be wrong done.
                </p>
            </method>

            <method name="getOwnerElement"
                    synopsis="$node = $attr->getOwnerElement();">
                <p>
                    returns the node the attribute belongs to. If the
                    attribute is not bound to a node, undef will be
                    returned. Overwriting the underlaying
                    implementation, the <st>parentNode</st> function
                    will return undef, instead of the owner element.
                </p>
            </method>

            <method name="setNamespace"
                    synopsis="$attr->setNamespace($nsURI, $prefix);">
                <p>
                    This function activates a namespace for the given
                    attribute. If the attribute was not previously
                    declared in the context of the attribute this
                    function will be silently ignored. In this case
                    you may wish to call setNamespace() on the
                    ownerElement.
                </p>
            </method>
        </description>
        <also>
            <item name="XML::LibXML"/>
            <item name="XML::LibXML::Node"/>
            <item name="XML::LibXML::Element"/>
            <item name="XML::LibXML::Document"/>
            <item name="XML::LibXML::DocumentFragment"/>
        </also>
    </package>

    <package name="XML::LibXML::DocumentFragment">
        <short>DOM L2 Implementation of a Document Fragment</short>
        <description>
            <p>
                This class is a helper class as described in the DOM
                Level 2 Specification.  It is implamented as a node
                without name. All adding, inserting or replacing
                functions are aware about document fragments now.
            </p>
            <p>
                As well <st>all</st> unbound nodes (all nodes that
                does not belong to any document subtree) are implicit
                member of document fragments.
            </p>
        </description>
        <also>
            <item name="XML::LibXML"/>
            <item name="XML::LibXML::Node"/>
            <item name="XML::LibXML::Element"/>
            <item name="XML::LibXML::Document"/>
            <item name="XML::LibXML::Text"/>
            <item name="XML::LibXML::Comment"/>
            <item name="XML::LibXML::CDATASection"/>
        </also>
    </package>

    <package name="XML::LibXML::Namespace">
        <short>A Namespace Class to hold namespace nodes</short>
        <description>
            <p>
                Namespace nodes are returned by both
                $element->findnodes('namespace::foo') or by
                $node->getNamespaces().
            </p>
            <p>
                The namespace node API is not part of any current DOM
                API, and so it is quite minimal. It should be noted
                that namespace nodes are <st>not</st> a sub class of
                XML::LibXML::Node, however Namespace nodes act a lot
                like attribute nodes, and similarly named methods will
                return what you would expect if you treated the
                namespace node as an attribute.
            </p>
            
            <method name="new" synopsis="my $ns = XML::LibXML::Namespace->new($nsURI);">
                <p>
                    Creates a new Namespace node. Note that this is
                    not a 'node' as an attribute or an element
                    node. Therefore you can't do call all
                    XML::LibXML::Node Functions. All functions
                    available for this node are listed below.
                </p>
                <p>
                    optionally you can pass the prefix to the
                    namespace constructor. If this second parameter is
                    ommited you will create a so called default
                    namespace. Note, the newly created namespace is
                    not bound to any docuement or node, therefore you
                    should not expect it to be available in an
                    existing document.
                </p>
            </method>

            
            <method name="getName" synopsis="print $ns->getName()">
                <p>
                    Returns "xmlns:prefix", where prefix is the prefix
                    for this namespace.
                </p>
            </method>

            <method name="name" synopsis="print $ns->name()">
                <p>
                    Alias for getName()
                </p>
            </method>

            <method name="prefix" synopsis="print $ns->prefix()">
                <p>
                    Returns the prefix bound to this namespace declaration.
                </p>
            </method>

            <method name="getLocalName" synopsis="$localname = $ns->getLocalName()">
                <p>
                    Alias for prefix()
                </p>
            </method>

            <method name="getData" synopsis="print $ns->getData()">
                <p>
                    Returns the URI of the namespace.
                </p>
            </method>

            <method name="getValue" synopsis="print $ns->getValue()">
                <p>
                    Alias for getData()
                </p>
            </method>

            <method name="value" synopsis="print $ns->value()">
                <p>
                    Alias for getData()
                </p>
            </method>

            <method name="uri" synopsis="print $ns->uri()">
                <p>
                    Alias for getData()
                </p>
            </method>

            <method name="getNamespaceURI" 
                    synopsis="$known_uri = $ns->getNamespaceURI()">
                <p>
                    Returns the string "http://www.w3.org/2000/xmlns/"
                </p>
            </method>

            <method name="getPrefix"
                    synopsis="$known_prefix = $ns->getPredix()">
                <p>
                    Returns the string "xmlns"
                </p>
            </method>
        </description>
    </package>

    <package name="XML::LibXML::Dtd">
        <short>A Class implementing Dtd Nodes</short>
        <description>
            <p>
                This class holds a DTD. You may parse a DTD from
                either a string, or from an external SYSTEM
                identifier.
            </p>
            <p>
                No support is available as yet for parsing from a
                filehandle.
            </p>
            <p>
                XML::LibXML::Dtd is a sub-class of Node, so all the
                methods available to nodes (particularly toString())
                are available to Dtd objects.
            </p>

            <method name="new" 
                    synopsis="$dtd = XML::LibXML::Dtd->new($public_id, $system_id)">
                <p>
                    Parse a DTD from the system identifier, and return
                    a DTD object that you can pass to $doc->is_valid()
                    or $doc->validate().
                </p>
  
                <example><![CDATA[
 my $dtd = XML::LibXML::Dtd->new(
                      "SOME // Public / ID / 1.0",
                      "test.dtd"
                                );
 my $doc = XML::LibXML->new->parse_file("test.xml");
 $doc->validate($dtd);
                    ]]></example>
            </method>

            <method name="parse_string"
                    synopsis="$dtd = XML::LibXML::Dtd->parse_string($dtd_str)">
                <p>
                    The same as new() above, except you can parse a
                    DTD from a string.
                </p>
            </method>
        </description>
    </package>
</module>
