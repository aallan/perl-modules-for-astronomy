[%#
  # IMPORTANT NOTE
  #   This documentation is generated automatically from source
  #   templates.  Any changes you make here may be lost.
  # 
  #   The 'docsrc' documentation source bundle is available for download
  #   from http://www.template-toolkit.org/docs.html and contains all
  #   the source templates, XML files, scripts, etc., from which the
  #   documentation for the Template Toolkit is built.
-%]
[% META book = 'Modules'
        page = 'Plugin_XML_DOM'
%]
[%  WRAPPER toc;
	PROCESS tocitem 
	        title ="SYNOPSIS"
                subs  = [];
	PROCESS tocitem 
	        title ="PRE-REQUISITES"
                subs  = [];
	PROCESS tocitem 
	        title ="DESCRIPTION"
                subs  = [];
	PROCESS tocitem 
	        title ="METHODS"
                subs  = [
                    "parse()",
		    "toTemplate()",
		    "childrenToTemplate()",
		    "allChildrenToTemplate()"
		];
	PROCESS tocitem 
	        title ="PRESENTING DOM NODES USING VIEWS"
                subs  = [];
	PROCESS tocitem 
	        title ="AUTHORS"
                subs  = [];
	PROCESS tocitem 
	        title ="VERSION"
                subs  = [];
	PROCESS tocitem 
	        title ="HISTORY"
                subs  = [];
	PROCESS tocitem 
	        title ="BUGS"
                subs  = [];
	PROCESS tocitem 
	        title ="COPYRIGHT"
                subs  = [];
	PROCESS tocitem 
	        title ="SEE ALSO"
                subs  = [];
    END
%]
<!-- Pod to HTML conversion by the Template Toolkit version 2 -->
[% WRAPPER section
    title="SYNOPSIS"
-%]<pre>    # load plugin
    [% tt_start_tag %] USE dom = XML.DOM [% tt_end_tag %]</pre>
<pre>    # also provide XML::Parser options
    [% tt_start_tag %] USE dom = XML.DOM(ProtocolEncoding =E&lt;gt&gt; 'ISO-8859-1') [% tt_end_tag %]</pre>
<pre>    # parse an XML file
    [% tt_start_tag %] doc = dom.parse(filename) [% tt_end_tag %]
    [% tt_start_tag %] doc = dom.parse(file =&gt; filename) [% tt_end_tag %]</pre>
<pre>    # parse XML text
    [% tt_start_tag %] doc = dom.parse(xmltext) [% tt_end_tag %]
    [% tt_start_tag %] doc = dom.parse(text =&gt; xmltext) [% tt_end_tag %]</pre>
<pre>    # call any XML::DOM methods on document/element nodes
    [% tt_start_tag %] FOREACH node = doc.getElementsByTagName('report') [% tt_end_tag %]
       * [% tt_start_tag %] node.getAttribute('title') [% tt_end_tag %]     # or just '[% tt_start_tag %] node.title [% tt_end_tag %]'
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
<pre>    # define VIEW to present node(s)
    [% tt_start_tag %] VIEW report notfound='xmlstring' [% tt_end_tag %]
       # handler block for a &lt;report&gt;...&lt;/report&gt; element
       [% tt_start_tag %] BLOCK report [% tt_end_tag %]
          [% tt_start_tag %] item.content(view) [% tt_end_tag %]
       [% tt_start_tag %] END [% tt_end_tag %]</pre>
<pre>       # handler block for a &lt;section title=&quot;...&quot;&gt;...&lt;/section&gt; element
       [% tt_start_tag %] BLOCK section [% tt_end_tag %]
       &lt;h1&gt;[% tt_start_tag %] item.title [% tt_end_tag %]&lt;/h1&gt;
       [% tt_start_tag %] item.content(view) [% tt_end_tag %]
       [% tt_start_tag %] END [% tt_end_tag %]</pre>
<pre>       # default template block converts item to string representation
       [% tt_start_tag %] BLOCK xmlstring; item.toString; END [% tt_end_tag %]
       
       # block to generate simple text
       [% tt_start_tag %] BLOCK text; item; END [% tt_end_tag %]
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
<pre>    # now present node (and children) via view
    [% tt_start_tag %] report.print(node) [% tt_end_tag %]</pre>
<pre>    # or print node content via view
    [% tt_start_tag %] node.content(report) [% tt_end_tag %]</pre>
<pre>    # following methods are soon to be deprecated in favour of views
    [% tt_start_tag %] node.toTemplate [% tt_end_tag %]
    [% tt_start_tag %] node.childrenToTemplate [% tt_end_tag %]
    [% tt_start_tag %] node.allChildrenToTemplate [% tt_end_tag %]</pre>
[%- END %]
[% WRAPPER section
    title="PRE-REQUISITES"
-%]<p>
This plugin requires that the XML::Parser (2.19 or later) and XML::DOM
(1.27 or later) modules be installed.  These are available from CPAN:
</p>
<pre>    http://www.cpan.org/modules/by-module/XML</pre>
<p>
Note that the XML::DOM module is now distributed as part of the
'libxml-enno' bundle.
</p>
[%- END %]
[% WRAPPER section
    title="DESCRIPTION"
-%]<p>
This is a Template Toolkit plugin interfacing to the XML::DOM module.
The plugin loads the XML::DOM module and creates an XML::DOM::Parser
object which is stored internally.  The parse() method can then be
called on the plugin to parse an XML stream into a DOM document.
</p>
<pre>    [% tt_start_tag %] USE dom = XML.DOM [% tt_end_tag %]
    [% tt_start_tag %] doc = dom.parse('/tmp/myxmlfile') [% tt_end_tag %]</pre>
<p>
NOTE: earlier versions of this XML::DOM plugin expected a filename to
be passed as an argument to the constructor.  This is no longer
supported due to the fact that it caused a serious memory leak.  We
apologise for the inconvenience but must insist that you change your
templates as shown:
</p>
<pre>    # OLD STYLE: now fails with a warning
    [% tt_start_tag %] USE dom = XML.DOM('tmp/myxmlfile') [% tt_end_tag %]</pre>
<pre>    # NEW STYLE: do this instead
    [% tt_start_tag %] USE dom = XML.DOM [% tt_end_tag %]
    [% tt_start_tag %] doc = dom.parse('tmp/myxmlfile') [% tt_end_tag %]</pre>
<p>
The root of the problem lies in XML::DOM creating massive circular
references in the object models it constructs.  The dispose() method
must be called on each document to release the memory that it would
otherwise hold indefinately.  The XML::DOM plugin object (i.e. 'dom'
in these examples) acts as a sentinel for the documents it creates
('doc' and any others).  When the plugin object goes out of scope at
the end of the current template, it will automatically call dispose()
on any documents that it has created.  Note that if you dispose of the
the plugin object before the end of the block (i.e.  by assigning a
new value to the 'dom' variable) then the documents will also be
disposed at that point and should not be used thereafter.
</p>
<pre>    [% tt_start_tag %] USE dom = XML.DOM [% tt_end_tag %]
    [% tt_start_tag %] doc = dom.parse('/tmp/myfile') [% tt_end_tag %]
    [% tt_start_tag %] dom = 'new value' [% tt_end_tag %]     # releases XML.DOM plugin and calls
                                # dispose() on 'doc', so don't use it!</pre>
<p>
Any template processing parameters (see toTemplate() method and
friends, below) can be specified with the constructor and will be used
to define defaults for the object.
</p>
<pre>    [% tt_start_tag %] USE dom = XML.DOM(prefix =&gt; 'theme1/') [% tt_end_tag %]</pre>
<p>
The plugin constructor will also accept configuration options destined
for the XML::Parser object:
</p>
<pre>    [% tt_start_tag %] USE dom = XML.DOM(ProtocolEncoding =&gt; 'ISO-8859-1') [% tt_end_tag %]</pre>
[%- END %]
[% WRAPPER section
    title="METHODS"
-%][% WRAPPER subsection
   title = "parse()"
-%]<p>
The parse() method accepts a positional parameter which contains a filename
or XML string.  It is assumed to be a filename unless it contains a &lt;
character.
</p>
<pre>    [% tt_start_tag %] xmlfile = '/tmp/foo.xml' [% tt_end_tag %]
    [% tt_start_tag %] doc = dom.parse(xmlfile) [% tt_end_tag %]</pre>
<pre>    [% tt_start_tag %] xmltext = BLOCK [% tt_end_tag %]
    &lt;xml&gt;
      &lt;blah&gt;&lt;etc/&gt;&lt;/blah&gt;
      ...
    &lt;/xml&gt;
    [% tt_start_tag %] END [% tt_end_tag %]
    [% tt_start_tag %] doc = dom.parse(xmltext) [% tt_end_tag %]</pre>
<p>
The named parameters 'file' (or 'filename') and 'text' (or 'xml') can also
be used:
</p>
<pre>    [% tt_start_tag %] doc = dom.parse(file = xmlfile) [% tt_end_tag %]
    [% tt_start_tag %] doc = dom.parse(text = xmltext) [% tt_end_tag %]</pre>
<p>
The parse() method returns an instance of the XML::DOM::Document object 
representing the parsed document in DOM form.  You can then call any 
XML::DOM methods on the document node and other nodes that its methods
may return.  See [% ttlink('XML::DOM') -%] for full details.
</p>
<pre>    [% tt_start_tag %] FOREACH node = doc.getElementsByTagName('CODEBASE') [% tt_end_tag %]
       * [% tt_start_tag %] node.getAttribute('href') [% tt_end_tag %]
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
<p>
This plugin also provides an AUTOLOAD method for XML::DOM::Node which 
calls getAttribute() for any undefined methods.  Thus, you can use the 
short form of 
</p>
<pre>    [% tt_start_tag %] node.attrib [% tt_end_tag %]</pre>
<p>
in place of
</p>
<pre>    [% tt_start_tag %] node.getAttribute('attrib') [% tt_end_tag %]</pre>
[%- END %]
[% WRAPPER subsection
   title = "toTemplate()"
-%]<p>
<b>NOTE: This method will soon be deprecated in favour of the VIEW based
approach desribed below.</b>
</p>
<p>
This method will process a template for the current node on which it is 
called.  The template name is constructed from the node TagName with any
optional 'prefix' and/or 'suffix' options applied.  A 'default' template 
can be named to be used when the specific template cannot be found.  The 
node object is available to the template as the 'node' variable.
</p>
<p>
Thus, for this XML fragment:
</p>
<pre>    &lt;page title=&quot;Hello World!&quot;&gt;
       ...
    &lt;/page&gt;</pre>
<p>
and this template definition:
</p>
<pre>    [% tt_start_tag %] BLOCK page [% tt_end_tag %]
    Page: [% tt_start_tag %] node.title [% tt_end_tag %]
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
<p>
the output of calling toTemplate() on the &lt;page&gt; node would be:
</p>
<pre>    Page: Hello World!</pre>
[%- END %]
[% WRAPPER subsection
   title = "childrenToTemplate()"
-%]<p>
<b>NOTE: This method will soon be deprecated in favour of the VIEW based
approach desribed below.</b>
</p>
<p>
Effectively calls toTemplate() for the current node and then for each of 
the node's children.  By default, the parent template is processed first,
followed by each of the children.  The 'children' closure can be called
from within the parent template to have them processed and output 
at that point.  This then suppresses the children from being processed
after the parent template.
</p>
<p>
Thus, for this XML fragment:
</p>
<pre>    &lt;foo&gt;
      &lt;bar id=&quot;1&quot;/&gt;
      &lt;bar id=&quot;2&quot;/&gt;
    &lt;/foo&gt;</pre>
<p>
and these template definitions:
</p>
<pre>    [% tt_start_tag %] BLOCK foo [% tt_end_tag %]
    start of foo
    end of foo 
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
<pre>    [% tt_start_tag %] BLOCK bar [% tt_end_tag %]
    bar [% tt_start_tag %] node.id [% tt_end_tag %]
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
<p>
the output of calling childrenToTemplate() on the parent &lt;foo&gt; node 
would be:
</p>
<pre>    start of foo
    end of foo
    bar 1
    bar 2</pre>
<p>
Adding a call to [% tt_start_tag %] children [% tt_end_tag %] in the 'foo' template:
</p>
<pre>    [% tt_start_tag %] BLOCK foo [% tt_end_tag %]
    start of foo
    [% tt_start_tag %] children [% tt_end_tag %]
    end of foo 
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
<p>
then creates output as:
</p>
<pre>    start of foo
    bar 1 
    bar 2
    end of foo</pre>
<p>
The 'children' closure can also be called as a method of the node, if you 
prefer:
</p>
<pre>    [% tt_start_tag %] BLOCK foo [% tt_end_tag %]
    start of foo
    [% tt_start_tag %] node.children [% tt_end_tag %]
    end of foo 
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
<p>
The 'prune' closure is also defined and can be called as [% tt_start_tag %] prune [% tt_end_tag %] or
[% tt_start_tag %] node.prune [% tt_end_tag %].  It prunes the currrent node, preventing any descendants
from being further processed.
</p>
<pre>    [% tt_start_tag %] BLOCK anynode [% tt_end_tag %]
    [% tt_start_tag %] node.toString; node.prune [% tt_end_tag %]
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
[%- END %]
[% WRAPPER subsection
   title = "allChildrenToTemplate()"
-%]<p>
<b>NOTE: This method will soon be deprecated in favour of the VIEW based
approach desribed below.</b>
</p>
<p>
Similar to childrenToTemplate() but processing all descendants (i.e. children
of children and so on) recursively.  This is identical to calling the 
childrenToTemplate() method with the 'deep' flag set to any true value.
</p>
[%- END %]
[%- END %]
[% WRAPPER section
    title="PRESENTING DOM NODES USING VIEWS"
-%]<p>
You can define a VIEW to present all or part of a DOM tree by automatically
mapping elements onto templates.  Consider a source document like the
following:
</p>
<pre>    &lt;report&gt;
      &lt;section title=&quot;Introduction&quot;&gt;
        &lt;p&gt;
        Blah blah.
        &lt;ul&gt;
          &lt;li&gt;Item 1&lt;/li&gt;
          &lt;li&gt;item 2&lt;/li&gt;
        &lt;/ul&gt;
        &lt;/p&gt;
      &lt;/section&gt;
      &lt;section title=&quot;The Gory Details&quot;&gt;
        ...
      &lt;/section&gt;
    &lt;/report&gt;</pre>
<p>
We can load it up via the XML::DOM plugin and fetch the node for the 
&lt;report&gt; element.
</p>
<pre>    [% tt_start_tag %] USE dom = XML.DOM;
       doc = dom.parse(file =&gt; filename);
       report = doc.getElementsByTagName('report')
    [% tt_end_tag %]</pre>
<p>
We can then define a VIEW as follows to present this document fragment in 
a particular way.  The [% ttlink('Template::Manual::Views') -%] documentation
contains further details on the VIEW directive and various configuration
options it supports.
</p>
<pre>    [% tt_start_tag %] VIEW report_view notfound='xmlstring' [% tt_end_tag %]
       # handler block for a &lt;report&gt;...&lt;/report&gt; element
       [% tt_start_tag %] BLOCK report [% tt_end_tag %]
          [% tt_start_tag %] item.content(view) [% tt_end_tag %]
       [% tt_start_tag %] END [% tt_end_tag %]</pre>
<pre>       # handler block for a &lt;section title=&quot;...&quot;&gt;...&lt;/section&gt; element
       [% tt_start_tag %] BLOCK section [% tt_end_tag %]
       &lt;h1&gt;[% tt_start_tag %] item.title [% tt_end_tag %]&lt;/h1&gt;
       [% tt_start_tag %] item.content(view) [% tt_end_tag %]
       [% tt_start_tag %] END [% tt_end_tag %]</pre>
<pre>       # default template block converts item to string representation
       [% tt_start_tag %] BLOCK xmlstring; item.toString; END [% tt_end_tag %]
       
       # block to generate simple text
       [% tt_start_tag %] BLOCK text; item; END [% tt_end_tag %]
    [% tt_start_tag %] END [% tt_end_tag %]</pre>
<p>
Each BLOCK defined within the VIEW represents a presentation style for 
a particular element or elements.  The current node is available via the
'item' variable.  Elements that contain other content can generate it
according to the current view by calling [% tt_start_tag %] item.content(view) [% tt_end_tag %].
Elements that don't have a specific template defined are mapped to the
'xmlstring' template via the 'notfound' parameter specified in the VIEW
header.  This replicates the node as an XML string, effectively allowing
general XML/XHTML markup to be passed through unmodified.
</p>
<p>
To present the report node via the view, we simply call:
</p>
<pre>    [% tt_start_tag %] report_view.print(report) [% tt_end_tag %]</pre>
<p>
The output from the above example would look something like this:
</p>
<pre>    &lt;h1&gt;Introduction&lt;/h1&gt;
    &lt;p&gt;
    Blah blah.
    &lt;ul&gt;
      &lt;li&gt;Item 1&lt;/li&gt;
      &lt;li&gt;item 2&lt;/li&gt;
    &lt;/ul&gt;
    &lt;/p&gt;
  
    &lt;h1&gt;The Gory Details&lt;/h1&gt;
    ...</pre>
<p>
To print just the content of the report node (i.e. don't process the
'report' template for the report node), you can call:
</p>
<pre>    [% tt_start_tag %] report.content(report_view) [% tt_end_tag %]</pre>
[%- END %]
[% WRAPPER section
    title="AUTHORS"
-%]<p>
This plugin module was written by Andy Wardley &lt;abw@wardley.org&gt;
and Simon Matthews &lt;sam@knowledgepool.com&gt;.
</p>
<p>
The XML::DOM module is by Enno Derksen &lt;enno@att.com&gt; and Clark 
Cooper &lt;coopercl@sch.ge.com&gt;.  It extends the the XML::Parser 
module, also by Clark Cooper which itself is built on James Clark's expat
library.
</p>
[%- END %]
[% WRAPPER section
    title="VERSION"
-%]<p>
2.6, distributed as part of the
Template Toolkit version 2.13, released on 30 January 2004.
</p>
[%- END %]
[% WRAPPER section
    title="HISTORY"
-%]<p>
Version 2.5 : updated for use with version 1.27 of the XML::DOM module.
</p>
<ul>
<li><p>
XML::DOM 1.27 now uses array references as the underlying data type
for DOM nodes instead of hash array references.  User data is now
bound to the _UserData node entry instead of being forced directly
into the node hash.
</p>

</ul>
[%- END %]
[% WRAPPER section
    title="BUGS"
-%]<p>
The childrenToTemplate() and allChildrenToTemplate() methods can easily
slip into deep recursion.
</p>
<p>
The 'verbose' and 'nospace' options are not documented.  They may 
change in the near future.
</p>
[%- END %]
[% WRAPPER section
    title="COPYRIGHT"
-%]<p>
Copyright (C) 2000-2001 Andy Wardley, Simon Matthews.  All Rights Reserved.
</p>
<p>
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
</p>
[%- END %]
[% WRAPPER section
    title="SEE ALSO"
-%]<p>
[% ttlink('Template::Plugin', 'Template::Plugin') -%], [% ttlink('XML::DOM', 'XML::DOM') -%], [% ttlink('XML::Parser', 'XML::Parser') -%]
</p>
[%- END %]



